package com.android.server;

import android.app.ActivityManagerNative;
import android.app.AlarmManager;
import android.app.AlarmManager.OnAlarmListener;
import android.content.BroadcastReceiver;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.ContentObserver;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.hardware.TriggerEvent;
import android.hardware.TriggerEventListener;
import android.hardware.display.DisplayManager;
import android.hardware.display.DisplayManager.DisplayListener;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.location.LocationRequest;
import android.net.INetworkPolicyManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.Binder;
import android.os.Bundle;
import android.os.Environment;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IDeviceIdleController.Stub;
import android.os.IMaintenanceActivityListener;
import android.os.Looper;
import android.os.Message;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.os.PowerManagerInternal;
import android.os.Process;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.ServiceManager;
import android.os.ShellCommand;
import android.os.SystemClock;
import android.os.UserHandle;
import android.provider.Settings.Global;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.KeyValueListParser;
import android.util.Log;
import android.util.MutableLong;
import android.util.Pair;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseBooleanArray;
import android.util.TimeUtils;
import android.util.Xml;
import android.view.Display;
import com.android.internal.app.IBatteryStats;
import com.android.internal.os.AtomicFile;
import com.android.internal.os.BackgroundThread;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.XmlUtils;
import com.android.server.am.BatteryStatsService;
import com.android.server.am.HwBroadcastRadarUtil;
import com.android.server.job.controllers.JobStatus;
import com.android.server.location.LocationFudger;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

public class DeviceIdleController extends SystemService implements DeviceIdleCallback {
    private static final boolean COMPRESS_TIME = false;
    private static boolean DEBUG = false;
    private static final int EVENT_BUFFER_SIZE = 100;
    private static final int EVENT_DEEP_IDLE = 4;
    private static final int EVENT_DEEP_MAINTENANCE = 5;
    private static final int EVENT_LIGHT_IDLE = 2;
    private static final int EVENT_LIGHT_MAINTENANCE = 3;
    private static final int EVENT_NORMAL = 1;
    private static final int EVENT_NULL = 0;
    private static final int LIGHT_STATE_ACTIVE = 0;
    private static final int LIGHT_STATE_IDLE = 4;
    private static final int LIGHT_STATE_IDLE_MAINTENANCE = 6;
    private static final int LIGHT_STATE_INACTIVE = 1;
    private static final int LIGHT_STATE_OVERRIDE = 7;
    private static final int LIGHT_STATE_PRE_IDLE = 3;
    private static final int LIGHT_STATE_WAITING_FOR_NETWORK = 5;
    static final int MSG_FINISH_IDLE_OP = 8;
    static final int MSG_REPORT_ACTIVE = 5;
    static final int MSG_REPORT_IDLE_OFF = 4;
    static final int MSG_REPORT_IDLE_ON = 2;
    static final int MSG_REPORT_IDLE_ON_LIGHT = 3;
    static final int MSG_REPORT_MAINTENANCE_ACTIVITY = 7;
    static final int MSG_TEMP_APP_WHITELIST_TIMEOUT = 6;
    static final int MSG_WRITE_CONFIG = 1;
    private static final int READ_DB_DELAY_TIME = 10000;
    private static final int STATE_ACTIVE = 0;
    private static final int STATE_IDLE = 5;
    private static final int STATE_IDLE_MAINTENANCE = 6;
    private static final int STATE_IDLE_PENDING = 2;
    private static final int STATE_INACTIVE = 1;
    private static final int STATE_LOCATING = 4;
    private static final int STATE_SENSING = 3;
    private static final String TAG = "DeviceIdleController";
    private int mActiveIdleOpCount;
    private WakeLock mActiveIdleWakeLock;
    private AlarmManager mAlarmManager;
    private boolean mAlarmsActive;
    private AnyMotionDetector mAnyMotionDetector;
    private IBatteryStats mBatteryStats;
    BinderService mBinderService;
    private boolean mCharging;
    public final AtomicFile mConfigFile = new AtomicFile(new File(getSystemDir(), "deviceidle.xml"));
    private ConnectivityService mConnectivityService;
    private Constants mConstants;
    private Display mCurDisplay;
    private long mCurIdleBudget;
    private final OnAlarmListener mDeepAlarmListener = new OnAlarmListener() {
        public void onAlarm() {
            synchronized (DeviceIdleController.this) {
                DeviceIdleController.this.stepIdleStateLocked("s:alarm");
            }
        }
    };
    private boolean mDeepEnabled;
    private final DisplayListener mDisplayListener = new DisplayListener() {
        public void onDisplayAdded(int displayId) {
        }

        public void onDisplayRemoved(int displayId) {
        }

        public void onDisplayChanged(int displayId) {
            if (displayId == 0) {
                synchronized (DeviceIdleController.this) {
                    DeviceIdleController.this.updateDisplayLocked();
                }
            }
        }
    };
    private DisplayManager mDisplayManager;
    private final int[] mEventCmds = new int[100];
    private final long[] mEventTimes = new long[100];
    private boolean mForceIdle;
    private final LocationListener mGenericLocationListener = new LocationListener() {
        public void onLocationChanged(Location location) {
            synchronized (DeviceIdleController.this) {
                DeviceIdleController.this.receivedGenericLocationLocked(location);
            }
        }

        public void onStatusChanged(String provider, int status, Bundle extras) {
        }

        public void onProviderEnabled(String provider) {
        }

        public void onProviderDisabled(String provider) {
        }
    };
    private final LocationListener mGpsLocationListener = new LocationListener() {
        public void onLocationChanged(Location location) {
            synchronized (DeviceIdleController.this) {
                DeviceIdleController.this.receivedGpsLocationLocked(location);
            }
        }

        public void onStatusChanged(String provider, int status, Bundle extras) {
        }

        public void onProviderEnabled(String provider) {
        }

        public void onProviderDisabled(String provider) {
        }
    };
    final MyHandler mHandler = new MyHandler(BackgroundThread.getHandler().getLooper());
    private boolean mHasGps;
    private boolean mHasNetworkLocation;
    private Intent mIdleIntent;
    private final BroadcastReceiver mIdleStartedDoneReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            if ("android.os.action.DEVICE_IDLE_MODE_CHANGED".equals(intent.getAction())) {
                DeviceIdleController.this.mHandler.sendEmptyMessageDelayed(8, DeviceIdleController.this.mConstants.MIN_DEEP_MAINTENANCE_TIME);
            } else {
                DeviceIdleController.this.mHandler.sendEmptyMessageDelayed(8, DeviceIdleController.this.mConstants.MIN_LIGHT_MAINTENANCE_TIME);
            }
        }
    };
    private long mInactiveTimeout;
    private boolean mJobsActive;
    private Location mLastGenericLocation;
    private Location mLastGpsLocation;
    private final OnAlarmListener mLightAlarmListener = new OnAlarmListener() {
        public void onAlarm() {
            synchronized (DeviceIdleController.this) {
                DeviceIdleController.this.stepLightIdleStateLocked("s:alarm");
            }
        }
    };
    private boolean mLightEnabled;
    private Intent mLightIdleIntent;
    private int mLightState;
    private com.android.server.AlarmManagerService.LocalService mLocalAlarmManager;
    private PowerManagerInternal mLocalPowerManager;
    private boolean mLocated;
    private boolean mLocating;
    private LocationManager mLocationManager;
    private LocationRequest mLocationRequest;
    private final RemoteCallbackList<IMaintenanceActivityListener> mMaintenanceActivityListeners = new RemoteCallbackList();
    private long mMaintenanceStartTime;
    private final MotionListener mMotionListener = new MotionListener();
    private Sensor mMotionSensor;
    private boolean mNetworkConnected;
    private INetworkPolicyManager mNetworkPolicyManager;
    Runnable mNetworkPolicyTempWhitelistCallback;
    private long mNextAlarmTime;
    private long mNextIdleDelay;
    private long mNextIdlePendingDelay;
    private long mNextLightAlarmTime;
    private long mNextLightIdleDelay;
    private long mNextSensingTimeoutAlarmTime;
    private boolean mNotMoving;
    private PowerManager mPowerManager;
    private int[] mPowerSaveWhitelistAllAppIdArray = new int[0];
    private final SparseBooleanArray mPowerSaveWhitelistAllAppIds = new SparseBooleanArray();
    private final ArrayMap<String, Integer> mPowerSaveWhitelistApps = new ArrayMap();
    private final ArrayMap<String, Integer> mPowerSaveWhitelistAppsExceptIdle = new ArrayMap();
    private int[] mPowerSaveWhitelistExceptIdleAppIdArray = new int[0];
    private final SparseBooleanArray mPowerSaveWhitelistExceptIdleAppIds = new SparseBooleanArray();
    private final SparseBooleanArray mPowerSaveWhitelistSystemAppIds = new SparseBooleanArray();
    private final SparseBooleanArray mPowerSaveWhitelistSystemAppIdsExceptIdle = new SparseBooleanArray();
    private int[] mPowerSaveWhitelistUserAppIdArray = new int[0];
    private final SparseBooleanArray mPowerSaveWhitelistUserAppIds = new SparseBooleanArray();
    private final ArrayMap<String, Integer> mPowerSaveWhitelistUserApps = new ArrayMap();
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            boolean z = false;
            String action = intent.getAction();
            if (action.equals("android.net.conn.CONNECTIVITY_CHANGE")) {
                DeviceIdleController.this.updateConnectivityState(intent);
            } else if (action.equals("android.intent.action.BATTERY_CHANGED")) {
                synchronized (DeviceIdleController.this) {
                    int plugged = intent.getIntExtra("plugged", 0);
                    DeviceIdleController deviceIdleController = DeviceIdleController.this;
                    if (plugged != 0) {
                        z = true;
                    }
                    deviceIdleController.updateChargingLocked(z);
                }
            } else if (action.equals("android.intent.action.PACKAGE_REMOVED") && !intent.getBooleanExtra("android.intent.extra.REPLACING", false)) {
                Uri data = intent.getData();
                if (data != null) {
                    String ssp = data.getSchemeSpecificPart();
                    if (ssp != null) {
                        DeviceIdleController.this.removePowerSaveWhitelistAppInternal(ssp);
                    }
                }
            }
        }
    };
    private boolean mReportedMaintenanceActivity;
    private boolean mScreenOn;
    private final OnAlarmListener mSensingTimeoutAlarmListener = new OnAlarmListener() {
        public void onAlarm() {
            if (DeviceIdleController.this.mState == 3) {
                synchronized (DeviceIdleController.this) {
                    DeviceIdleController.this.becomeInactiveIfAppropriateLocked();
                }
            }
        }
    };
    private SensorManager mSensorManager;
    private int mState;
    private int[] mTempWhitelistAppIdArray = new int[0];
    private final SparseArray<Pair<MutableLong, String>> mTempWhitelistAppIdEndTimes = new SparseArray();

    private final class BinderService extends Stub {
        private BinderService() {
        }

        public void addPowerSaveWhitelistApp(String name) {
            DeviceIdleController.this.getContext().enforceCallingOrSelfPermission("android.permission.DEVICE_POWER", null);
            long ident = Binder.clearCallingIdentity();
            try {
                DeviceIdleController.this.addPowerSaveWhitelistAppInternal(name);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }

        public void removePowerSaveWhitelistApp(String name) {
            DeviceIdleController.this.getContext().enforceCallingOrSelfPermission("android.permission.DEVICE_POWER", null);
            long ident = Binder.clearCallingIdentity();
            try {
                DeviceIdleController.this.removePowerSaveWhitelistAppInternal(name);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }

        public String[] getSystemPowerWhitelistExceptIdle() {
            return DeviceIdleController.this.getSystemPowerWhitelistExceptIdleInternal();
        }

        public String[] getSystemPowerWhitelist() {
            return DeviceIdleController.this.getSystemPowerWhitelistInternal();
        }

        public String[] getUserPowerWhitelist() {
            return DeviceIdleController.this.getUserPowerWhitelistInternal();
        }

        public String[] getFullPowerWhitelistExceptIdle() {
            return DeviceIdleController.this.getFullPowerWhitelistExceptIdleInternal();
        }

        public String[] getFullPowerWhitelist() {
            return DeviceIdleController.this.getFullPowerWhitelistInternal();
        }

        public int[] getAppIdWhitelistExceptIdle() {
            return DeviceIdleController.this.getAppIdWhitelistExceptIdleInternal();
        }

        public int[] getAppIdWhitelist() {
            return DeviceIdleController.this.getAppIdWhitelistInternal();
        }

        public int[] getAppIdUserWhitelist() {
            return DeviceIdleController.this.getAppIdUserWhitelistInternal();
        }

        public int[] getAppIdTempWhitelist() {
            return DeviceIdleController.this.getAppIdTempWhitelistInternal();
        }

        public boolean isPowerSaveWhitelistExceptIdleApp(String name) {
            return DeviceIdleController.this.isPowerSaveWhitelistExceptIdleAppInternal(name);
        }

        public int getIdleStateDetailed() {
            DeviceIdleController.this.getContext().enforceCallingOrSelfPermission("android.permission.DEVICE_POWER", null);
            return DeviceIdleController.this.mState;
        }

        public int getLightIdleStateDetailed() {
            DeviceIdleController.this.getContext().enforceCallingOrSelfPermission("android.permission.DEVICE_POWER", null);
            return DeviceIdleController.this.mLightState;
        }

        public boolean isPowerSaveWhitelistApp(String name) {
            return DeviceIdleController.this.isPowerSaveWhitelistAppInternal(name);
        }

        public void addPowerSaveTempWhitelistApp(String packageName, long duration, int userId, String reason) throws RemoteException {
            DeviceIdleController.this.addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason);
        }

        public long addPowerSaveTempWhitelistAppForMms(String packageName, int userId, String reason) throws RemoteException {
            long duration = DeviceIdleController.this.mConstants.MMS_TEMP_APP_WHITELIST_DURATION;
            DeviceIdleController.this.addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason);
            return duration;
        }

        public long addPowerSaveTempWhitelistAppForSms(String packageName, int userId, String reason) throws RemoteException {
            long duration = DeviceIdleController.this.mConstants.SMS_TEMP_APP_WHITELIST_DURATION;
            DeviceIdleController.this.addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason);
            return duration;
        }

        public void exitIdle(String reason) {
            DeviceIdleController.this.getContext().enforceCallingOrSelfPermission("android.permission.DEVICE_POWER", null);
            long ident = Binder.clearCallingIdentity();
            try {
                DeviceIdleController.this.exitIdleInternal(reason);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }

        public boolean registerMaintenanceActivityListener(IMaintenanceActivityListener listener) {
            return DeviceIdleController.this.registerMaintenanceActivityListener(listener);
        }

        public void unregisterMaintenanceActivityListener(IMaintenanceActivityListener listener) {
            DeviceIdleController.this.unregisterMaintenanceActivityListener(listener);
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            DeviceIdleController.this.dump(fd, pw, args);
        }

        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ResultReceiver resultReceiver) {
            new Shell().exec(this, in, out, err, args, resultReceiver);
        }

        public int forceIdle() {
            if (1000 == Binder.getCallingUid()) {
                return DeviceIdleController.this.forceIdleInternal();
            }
            Slog.e(DeviceIdleController.TAG, " forceIdle error , permission not allowed. uid = " + Binder.getCallingUid());
            return -1;
        }
    }

    private final class Constants extends ContentObserver {
        private static final String KEY_IDLE_AFTER_INACTIVE_TIMEOUT = "idle_after_inactive_to";
        private static final String KEY_IDLE_FACTOR = "idle_factor";
        private static final String KEY_IDLE_PENDING_FACTOR = "idle_pending_factor";
        private static final String KEY_IDLE_PENDING_TIMEOUT = "idle_pending_to";
        private static final String KEY_IDLE_TIMEOUT = "idle_to";
        private static final String KEY_INACTIVE_TIMEOUT = "inactive_to";
        private static final String KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT = "light_after_inactive_to";
        private static final String KEY_LIGHT_IDLE_FACTOR = "light_idle_factor";
        private static final String KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET = "light_idle_maintenance_max_budget";
        private static final String KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET = "light_idle_maintenance_min_budget";
        private static final String KEY_LIGHT_IDLE_TIMEOUT = "light_idle_to";
        private static final String KEY_LIGHT_MAX_IDLE_TIMEOUT = "light_max_idle_to";
        private static final String KEY_LIGHT_PRE_IDLE_TIMEOUT = "light_pre_idle_to";
        private static final String KEY_LOCATING_TIMEOUT = "locating_to";
        private static final String KEY_LOCATION_ACCURACY = "location_accuracy";
        private static final String KEY_MAX_IDLE_PENDING_TIMEOUT = "max_idle_pending_to";
        private static final String KEY_MAX_IDLE_TIMEOUT = "max_idle_to";
        private static final String KEY_MAX_TEMP_APP_WHITELIST_DURATION = "max_temp_app_whitelist_duration";
        private static final String KEY_MIN_DEEP_MAINTENANCE_TIME = "min_deep_maintenance_time";
        private static final String KEY_MIN_LIGHT_MAINTENANCE_TIME = "min_light_maintenance_time";
        private static final String KEY_MIN_TIME_TO_ALARM = "min_time_to_alarm";
        private static final String KEY_MMS_TEMP_APP_WHITELIST_DURATION = "mms_temp_app_whitelist_duration";
        private static final String KEY_MOTION_INACTIVE_TIMEOUT = "motion_inactive_to";
        private static final String KEY_NOTIFICATION_WHITELIST_DURATION = "notification_whitelist_duration";
        private static final String KEY_SENSING_TIMEOUT = "sensing_to";
        private static final String KEY_SMS_TEMP_APP_WHITELIST_DURATION = "sms_temp_app_whitelist_duration";
        public long IDLE_AFTER_INACTIVE_TIMEOUT;
        public float IDLE_FACTOR;
        public float IDLE_PENDING_FACTOR;
        public long IDLE_PENDING_TIMEOUT;
        public long IDLE_TIMEOUT;
        public long INACTIVE_TIMEOUT;
        public long LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT;
        public float LIGHT_IDLE_FACTOR;
        public long LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
        public long LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
        public long LIGHT_IDLE_TIMEOUT;
        public long LIGHT_MAX_IDLE_TIMEOUT;
        public long LIGHT_PRE_IDLE_TIMEOUT;
        public long LOCATING_TIMEOUT;
        public float LOCATION_ACCURACY;
        public long MAX_IDLE_PENDING_TIMEOUT;
        public long MAX_IDLE_TIMEOUT;
        public long MAX_TEMP_APP_WHITELIST_DURATION;
        public long MIN_DEEP_MAINTENANCE_TIME;
        public long MIN_LIGHT_MAINTENANCE_TIME;
        public long MIN_TIME_TO_ALARM;
        public long MMS_TEMP_APP_WHITELIST_DURATION;
        public long MOTION_INACTIVE_TIMEOUT;
        public long NOTIFICATION_WHITELIST_DURATION;
        public long SENSING_TIMEOUT;
        public long SMS_TEMP_APP_WHITELIST_DURATION;
        private final boolean mHasWatch;
        private final KeyValueListParser mParser = new KeyValueListParser(',');
        private final ContentResolver mResolver;

        public Constants(Handler handler, ContentResolver resolver) {
            String str;
            super(handler);
            this.mResolver = resolver;
            this.mHasWatch = DeviceIdleController.this.getContext().getPackageManager().hasSystemFeature("android.hardware.type.watch");
            ContentResolver contentResolver = this.mResolver;
            if (this.mHasWatch) {
                str = "device_idle_constants_watch";
            } else {
                str = "device_idle_constants";
            }
            contentResolver.registerContentObserver(Global.getUriFor(str), false, this);
            updateConstants();
        }

        public void onChange(boolean selfChange, Uri uri) {
            updateConstants();
        }

        private void updateConstants() {
            synchronized (DeviceIdleController.this) {
                try {
                    String str;
                    KeyValueListParser keyValueListParser = this.mParser;
                    ContentResolver contentResolver = this.mResolver;
                    if (this.mHasWatch) {
                        str = "device_idle_constants_watch";
                    } else {
                        str = "device_idle_constants";
                    }
                    keyValueListParser.setString(Global.getString(contentResolver, str));
                } catch (IllegalArgumentException e) {
                    Slog.e(DeviceIdleController.TAG, "Bad device idle settings", e);
                }
                this.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT = this.mParser.getLong(KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT, 300000);
                this.LIGHT_PRE_IDLE_TIMEOUT = this.mParser.getLong(KEY_LIGHT_PRE_IDLE_TIMEOUT, LocationFudger.FASTEST_INTERVAL_MS);
                this.LIGHT_IDLE_TIMEOUT = this.mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT, 300000);
                this.LIGHT_IDLE_FACTOR = this.mParser.getFloat(KEY_LIGHT_IDLE_FACTOR, 2.0f);
                this.LIGHT_MAX_IDLE_TIMEOUT = this.mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT, 900000);
                this.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET = this.mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET, 60000);
                this.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET = this.mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET, 300000);
                this.MIN_LIGHT_MAINTENANCE_TIME = this.mParser.getLong(KEY_MIN_LIGHT_MAINTENANCE_TIME, 5000);
                this.MIN_DEEP_MAINTENANCE_TIME = this.mParser.getLong(KEY_MIN_DEEP_MAINTENANCE_TIME, 30000);
                this.INACTIVE_TIMEOUT = this.mParser.getLong(KEY_INACTIVE_TIMEOUT, ((long) ((this.mHasWatch ? 15 : 30) * 60)) * 1000);
                this.SENSING_TIMEOUT = this.mParser.getLong(KEY_SENSING_TIMEOUT, !DeviceIdleController.DEBUG ? 240000 : 60000);
                this.LOCATING_TIMEOUT = this.mParser.getLong(KEY_LOCATING_TIMEOUT, !DeviceIdleController.DEBUG ? 30000 : 15000);
                this.LOCATION_ACCURACY = this.mParser.getFloat(KEY_LOCATION_ACCURACY, 20.0f);
                this.MOTION_INACTIVE_TIMEOUT = this.mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT, LocationFudger.FASTEST_INTERVAL_MS);
                this.IDLE_AFTER_INACTIVE_TIMEOUT = this.mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT, ((long) ((this.mHasWatch ? 15 : 30) * 60)) * 1000);
                this.IDLE_PENDING_TIMEOUT = this.mParser.getLong(KEY_IDLE_PENDING_TIMEOUT, 300000);
                this.MAX_IDLE_PENDING_TIMEOUT = this.mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT, LocationFudger.FASTEST_INTERVAL_MS);
                this.IDLE_PENDING_FACTOR = this.mParser.getFloat(KEY_IDLE_PENDING_FACTOR, 2.0f);
                this.IDLE_TIMEOUT = this.mParser.getLong(KEY_IDLE_TIMEOUT, 3600000);
                this.MAX_IDLE_TIMEOUT = this.mParser.getLong(KEY_MAX_IDLE_TIMEOUT, 21600000);
                this.IDLE_FACTOR = this.mParser.getFloat(KEY_IDLE_FACTOR, 2.0f);
                this.MIN_TIME_TO_ALARM = this.mParser.getLong(KEY_MIN_TIME_TO_ALARM, 3600000);
                this.MAX_TEMP_APP_WHITELIST_DURATION = this.mParser.getLong(KEY_MAX_TEMP_APP_WHITELIST_DURATION, 300000);
                this.MMS_TEMP_APP_WHITELIST_DURATION = this.mParser.getLong(KEY_MMS_TEMP_APP_WHITELIST_DURATION, 60000);
                this.SMS_TEMP_APP_WHITELIST_DURATION = this.mParser.getLong(KEY_SMS_TEMP_APP_WHITELIST_DURATION, 20000);
                this.NOTIFICATION_WHITELIST_DURATION = this.mParser.getLong(KEY_NOTIFICATION_WHITELIST_DURATION, 30000);
            }
        }

        void dump(PrintWriter pw) {
            pw.println("  Settings:");
            pw.print("    ");
            pw.print(KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_LIGHT_PRE_IDLE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.LIGHT_PRE_IDLE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_LIGHT_IDLE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.LIGHT_IDLE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_LIGHT_IDLE_FACTOR);
            pw.print("=");
            pw.print(this.LIGHT_IDLE_FACTOR);
            pw.println();
            pw.print("    ");
            pw.print(KEY_LIGHT_MAX_IDLE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.LIGHT_MAX_IDLE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
            pw.print("=");
            TimeUtils.formatDuration(this.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET);
            pw.print("=");
            TimeUtils.formatDuration(this.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_MIN_LIGHT_MAINTENANCE_TIME);
            pw.print("=");
            TimeUtils.formatDuration(this.MIN_LIGHT_MAINTENANCE_TIME, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_MIN_DEEP_MAINTENANCE_TIME);
            pw.print("=");
            TimeUtils.formatDuration(this.MIN_DEEP_MAINTENANCE_TIME, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_INACTIVE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.INACTIVE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_SENSING_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.SENSING_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_LOCATING_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.LOCATING_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_LOCATION_ACCURACY);
            pw.print("=");
            pw.print(this.LOCATION_ACCURACY);
            pw.print("m");
            pw.println();
            pw.print("    ");
            pw.print(KEY_MOTION_INACTIVE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.MOTION_INACTIVE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_IDLE_AFTER_INACTIVE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.IDLE_AFTER_INACTIVE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_IDLE_PENDING_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.IDLE_PENDING_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_MAX_IDLE_PENDING_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.MAX_IDLE_PENDING_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_IDLE_PENDING_FACTOR);
            pw.print("=");
            pw.println(this.IDLE_PENDING_FACTOR);
            pw.print("    ");
            pw.print(KEY_IDLE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.IDLE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_MAX_IDLE_TIMEOUT);
            pw.print("=");
            TimeUtils.formatDuration(this.MAX_IDLE_TIMEOUT, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_IDLE_FACTOR);
            pw.print("=");
            pw.println(this.IDLE_FACTOR);
            pw.print("    ");
            pw.print(KEY_MIN_TIME_TO_ALARM);
            pw.print("=");
            TimeUtils.formatDuration(this.MIN_TIME_TO_ALARM, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_MAX_TEMP_APP_WHITELIST_DURATION);
            pw.print("=");
            TimeUtils.formatDuration(this.MAX_TEMP_APP_WHITELIST_DURATION, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_MMS_TEMP_APP_WHITELIST_DURATION);
            pw.print("=");
            TimeUtils.formatDuration(this.MMS_TEMP_APP_WHITELIST_DURATION, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_SMS_TEMP_APP_WHITELIST_DURATION);
            pw.print("=");
            TimeUtils.formatDuration(this.SMS_TEMP_APP_WHITELIST_DURATION, pw);
            pw.println();
            pw.print("    ");
            pw.print(KEY_NOTIFICATION_WHITELIST_DURATION);
            pw.print("=");
            TimeUtils.formatDuration(this.NOTIFICATION_WHITELIST_DURATION, pw);
            pw.println();
        }
    }

    public final class LocalService {
        public void addPowerSaveTempWhitelistAppDirect(int appId, long duration, boolean sync, String reason) {
            DeviceIdleController.this.addPowerSaveTempWhitelistAppDirectInternal(0, appId, duration, sync, reason);
        }

        public long getNotificationWhitelistDuration() {
            return DeviceIdleController.this.mConstants.NOTIFICATION_WHITELIST_DURATION;
        }

        public void setNetworkPolicyTempWhitelistCallback(Runnable callback) {
            DeviceIdleController.this.setNetworkPolicyTempWhitelistCallbackInternal(callback);
        }

        public void setJobsActive(boolean active) {
            DeviceIdleController.this.setJobsActive(active);
        }

        public void setAlarmsActive(boolean active) {
            DeviceIdleController.this.setAlarmsActive(active);
        }

        public int[] getPowerSaveWhitelistUserAppIds() {
            return DeviceIdleController.this.getPowerSaveWhitelistUserAppIds();
        }
    }

    private final class MotionListener extends TriggerEventListener implements SensorEventListener {
        boolean active;

        private MotionListener() {
            this.active = false;
        }

        public void onTrigger(TriggerEvent event) {
            synchronized (DeviceIdleController.this) {
                this.active = false;
                DeviceIdleController.this.motionLocked();
            }
        }

        public void onSensorChanged(SensorEvent event) {
            synchronized (DeviceIdleController.this) {
                DeviceIdleController.this.mSensorManager.unregisterListener(this, DeviceIdleController.this.mMotionSensor);
                this.active = false;
                DeviceIdleController.this.motionLocked();
            }
        }

        public void onAccuracyChanged(Sensor sensor, int accuracy) {
        }

        public boolean registerLocked() {
            boolean success;
            if (DeviceIdleController.this.mMotionSensor.getReportingMode() == 2) {
                success = DeviceIdleController.this.mSensorManager.requestTriggerSensor(DeviceIdleController.this.mMotionListener, DeviceIdleController.this.mMotionSensor);
            } else {
                success = DeviceIdleController.this.mSensorManager.registerListener(DeviceIdleController.this.mMotionListener, DeviceIdleController.this.mMotionSensor, 3);
            }
            if (success) {
                this.active = true;
            } else {
                Slog.e(DeviceIdleController.TAG, "Unable to register for " + DeviceIdleController.this.mMotionSensor);
            }
            return success;
        }

        public void unregisterLocked() {
            if (DeviceIdleController.this.mMotionSensor.getReportingMode() == 2) {
                DeviceIdleController.this.mSensorManager.cancelTriggerSensor(DeviceIdleController.this.mMotionListener, DeviceIdleController.this.mMotionSensor);
            } else {
                DeviceIdleController.this.mSensorManager.unregisterListener(DeviceIdleController.this.mMotionListener);
            }
            this.active = false;
        }
    }

    final class MyHandler extends Handler {
        MyHandler(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            if (DeviceIdleController.DEBUG) {
                Slog.d(DeviceIdleController.TAG, "handleMessage(" + msg.what + ")");
            }
            boolean deepChanged;
            boolean lightChanged;
            switch (msg.what) {
                case 1:
                    DeviceIdleController.this.handleWriteConfigFile();
                    return;
                case 2:
                case 3:
                    EventLogTags.writeDeviceIdleOnStart();
                    if (msg.what == 2) {
                        deepChanged = DeviceIdleController.this.mLocalPowerManager.setDeviceIdleMode(true);
                        lightChanged = DeviceIdleController.this.mLocalPowerManager.setLightDeviceIdleMode(false);
                    } else {
                        deepChanged = DeviceIdleController.this.mLocalPowerManager.setDeviceIdleMode(false);
                        lightChanged = DeviceIdleController.this.mLocalPowerManager.setLightDeviceIdleMode(true);
                    }
                    try {
                        int i;
                        DeviceIdleController.this.mNetworkPolicyManager.setDeviceIdleMode(true);
                        IBatteryStats -get1 = DeviceIdleController.this.mBatteryStats;
                        if (msg.what == 2) {
                            i = 2;
                        } else {
                            i = 1;
                        }
                        -get1.noteDeviceIdleMode(i, null, Process.myUid());
                    } catch (RemoteException e) {
                    }
                    if (deepChanged) {
                        DeviceIdleController.this.getContext().sendBroadcastAsUser(DeviceIdleController.this.mIdleIntent, UserHandle.ALL);
                    }
                    if (lightChanged) {
                        DeviceIdleController.this.getContext().sendBroadcastAsUser(DeviceIdleController.this.mLightIdleIntent, UserHandle.ALL);
                    }
                    EventLogTags.writeDeviceIdleOnComplete();
                    return;
                case 4:
                    EventLogTags.writeDeviceIdleOffStart("unknown");
                    deepChanged = DeviceIdleController.this.mLocalPowerManager.setDeviceIdleMode(false);
                    lightChanged = DeviceIdleController.this.mLocalPowerManager.setLightDeviceIdleMode(false);
                    try {
                        DeviceIdleController.this.mNetworkPolicyManager.setDeviceIdleMode(false);
                        DeviceIdleController.this.mBatteryStats.noteDeviceIdleMode(0, null, Process.myUid());
                    } catch (RemoteException e2) {
                    }
                    if (deepChanged) {
                        DeviceIdleController.this.incActiveIdleOps();
                        DeviceIdleController.this.getContext().sendOrderedBroadcastAsUser(DeviceIdleController.this.mIdleIntent, UserHandle.ALL, null, DeviceIdleController.this.mIdleStartedDoneReceiver, null, 0, null, null);
                    }
                    if (lightChanged) {
                        DeviceIdleController.this.incActiveIdleOps();
                        DeviceIdleController.this.getContext().sendOrderedBroadcastAsUser(DeviceIdleController.this.mLightIdleIntent, UserHandle.ALL, null, DeviceIdleController.this.mIdleStartedDoneReceiver, null, 0, null, null);
                    }
                    DeviceIdleController.this.decActiveIdleOps();
                    EventLogTags.writeDeviceIdleOffComplete();
                    return;
                case 5:
                    String activeReason = msg.obj;
                    int activeUid = msg.arg1;
                    EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : "unknown");
                    deepChanged = DeviceIdleController.this.mLocalPowerManager.setDeviceIdleMode(false);
                    lightChanged = DeviceIdleController.this.mLocalPowerManager.setLightDeviceIdleMode(false);
                    try {
                        DeviceIdleController.this.mNetworkPolicyManager.setDeviceIdleMode(false);
                        DeviceIdleController.this.mBatteryStats.noteDeviceIdleMode(0, activeReason, activeUid);
                    } catch (RemoteException e3) {
                    }
                    if (deepChanged) {
                        DeviceIdleController.this.getContext().sendBroadcastAsUser(DeviceIdleController.this.mIdleIntent, UserHandle.ALL);
                    }
                    if (lightChanged) {
                        DeviceIdleController.this.getContext().sendBroadcastAsUser(DeviceIdleController.this.mLightIdleIntent, UserHandle.ALL);
                    }
                    EventLogTags.writeDeviceIdleOffComplete();
                    return;
                case 6:
                    DeviceIdleController.this.checkTempAppWhitelistTimeout(msg.arg1);
                    return;
                case 7:
                    boolean active = msg.arg1 == 1;
                    int size = DeviceIdleController.this.mMaintenanceActivityListeners.beginBroadcast();
                    for (int i2 = 0; i2 < size; i2++) {
                        try {
                            ((IMaintenanceActivityListener) DeviceIdleController.this.mMaintenanceActivityListeners.getBroadcastItem(i2)).onMaintenanceActivityChanged(active);
                        } catch (RemoteException e4) {
                        } catch (Throwable th) {
                            DeviceIdleController.this.mMaintenanceActivityListeners.finishBroadcast();
                        }
                    }
                    DeviceIdleController.this.mMaintenanceActivityListeners.finishBroadcast();
                    return;
                case 8:
                    DeviceIdleController.this.decActiveIdleOps();
                    return;
                default:
                    return;
            }
        }
    }

    class Shell extends ShellCommand {
        int userId = 0;

        Shell() {
        }

        public int onCommand(String cmd) {
            return DeviceIdleController.this.onShellCommand(this, cmd);
        }

        public void onHelp() {
            DeviceIdleController.dumpHelp(getOutPrintWriter());
        }
    }

    int onShellCommand(com.android.server.DeviceIdleController.Shell r22, java.lang.String r23) {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unreachable block: B:84:0x017b
	at jadx.core.dex.visitors.blocksmaker.BlockProcessor.modifyBlocksTree(BlockProcessor.java:248)
	at jadx.core.dex.visitors.blocksmaker.BlockProcessor.processBlocksTree(BlockProcessor.java:52)
	at jadx.core.dex.visitors.blocksmaker.BlockProcessor.rerun(BlockProcessor.java:44)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.visit(BlockFinallyExtract.java:57)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:31)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:17)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:59)
	at jadx.core.ProcessClass.process(ProcessClass.java:42)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:306)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler$1.run(JadxDecompiler.java:199)
*/
        /*
        r21 = this;
        r16 = r22.getOutPrintWriter();
        r2 = "step";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x009a;
    L_0x000f:
        r2 = r21.getContext();
        r4 = "android.permission.DEVICE_POWER";
        r5 = 0;
        r2.enforceCallingOrSelfPermission(r4, r5);
        monitor-enter(r21);
        r18 = android.os.Binder.clearCallingIdentity();	 Catch:{ all -> 0x0078 }
        r3 = r22.getNextArg();	 Catch:{ all -> 0x0078 }
        if (r3 == 0) goto L_0x002e;
    L_0x0025:
        r2 = "deep";	 Catch:{ all -> 0x0078 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x0078 }
        if (r2 == 0) goto L_0x0051;	 Catch:{ all -> 0x0078 }
    L_0x002e:
        r2 = "s:shell";	 Catch:{ all -> 0x0078 }
        r0 = r21;	 Catch:{ all -> 0x0078 }
        r0.stepIdleStateLocked(r2);	 Catch:{ all -> 0x0078 }
        r2 = "Stepped to deep: ";	 Catch:{ all -> 0x0078 }
        r0 = r16;	 Catch:{ all -> 0x0078 }
        r0.print(r2);	 Catch:{ all -> 0x0078 }
        r0 = r21;	 Catch:{ all -> 0x0078 }
        r2 = r0.mState;	 Catch:{ all -> 0x0078 }
        r2 = stateToString(r2);	 Catch:{ all -> 0x0078 }
        r0 = r16;	 Catch:{ all -> 0x0078 }
        r0.println(r2);	 Catch:{ all -> 0x0078 }
    L_0x004b:
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x0078 }
    L_0x004e:
        monitor-exit(r21);
    L_0x004f:
        r2 = 0;
        return r2;
    L_0x0051:
        r2 = "light";	 Catch:{ all -> 0x0078 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x0078 }
        if (r2 == 0) goto L_0x0080;	 Catch:{ all -> 0x0078 }
    L_0x005a:
        r2 = "s:shell";	 Catch:{ all -> 0x0078 }
        r0 = r21;	 Catch:{ all -> 0x0078 }
        r0.stepLightIdleStateLocked(r2);	 Catch:{ all -> 0x0078 }
        r2 = "Stepped to light: ";	 Catch:{ all -> 0x0078 }
        r0 = r16;	 Catch:{ all -> 0x0078 }
        r0.print(r2);	 Catch:{ all -> 0x0078 }
        r0 = r21;	 Catch:{ all -> 0x0078 }
        r2 = r0.mLightState;	 Catch:{ all -> 0x0078 }
        r2 = lightStateToString(r2);	 Catch:{ all -> 0x0078 }
        r0 = r16;	 Catch:{ all -> 0x0078 }
        r0.println(r2);	 Catch:{ all -> 0x0078 }
        goto L_0x004b;
    L_0x0078:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x0078 }
        throw r2;	 Catch:{ all -> 0x0078 }
    L_0x007d:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x0080:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x0078 }
        r2.<init>();	 Catch:{ all -> 0x0078 }
        r4 = "Unknown idle mode: ";	 Catch:{ all -> 0x0078 }
        r2 = r2.append(r4);	 Catch:{ all -> 0x0078 }
        r2 = r2.append(r3);	 Catch:{ all -> 0x0078 }
        r2 = r2.toString();	 Catch:{ all -> 0x0078 }
        r0 = r16;	 Catch:{ all -> 0x0078 }
        r0.println(r2);	 Catch:{ all -> 0x0078 }
        goto L_0x004b;
    L_0x009a:
        r2 = "force-idle";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x0199;
    L_0x00a5:
        r2 = r21.getContext();
        r4 = "android.permission.DEVICE_POWER";
        r5 = 0;
        r2.enforceCallingOrSelfPermission(r4, r5);
        monitor-enter(r21);
        r18 = android.os.Binder.clearCallingIdentity();	 Catch:{ all -> 0x017a }
        r3 = r22.getNextArg();	 Catch:{ all -> 0x017a }
        if (r3 == 0) goto L_0x00c4;
    L_0x00bb:
        r2 = "deep";	 Catch:{ all -> 0x017a }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x017a }
        if (r2 == 0) goto L_0x0128;	 Catch:{ all -> 0x017a }
    L_0x00c4:
        r0 = r21;	 Catch:{ all -> 0x017a }
        r2 = r0.mDeepEnabled;	 Catch:{ all -> 0x017a }
        if (r2 != 0) goto L_0x00d8;	 Catch:{ all -> 0x017a }
    L_0x00ca:
        r2 = "Unable to go deep idle; not enabled";	 Catch:{ all -> 0x017a }
        r0 = r16;	 Catch:{ all -> 0x017a }
        r0.println(r2);	 Catch:{ all -> 0x017a }
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x017a }
        r2 = -1;
        monitor-exit(r21);
        return r2;
    L_0x00d8:
        r2 = 1;
        r0 = r21;	 Catch:{ all -> 0x017a }
        r0.mForceIdle = r2;	 Catch:{ all -> 0x017a }
        r21.becomeInactiveIfAppropriateLocked();	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r11 = r0.mState;	 Catch:{ all -> 0x017a }
    L_0x00e4:
        r2 = 5;	 Catch:{ all -> 0x017a }
        if (r11 == r2) goto L_0x0118;	 Catch:{ all -> 0x017a }
    L_0x00e7:
        r2 = "s:shell";	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r0.stepIdleStateLocked(r2);	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r2 = r0.mState;	 Catch:{ all -> 0x017a }
        if (r11 != r2) goto L_0x0113;	 Catch:{ all -> 0x017a }
    L_0x00f5:
        r2 = "Unable to go deep idle; stopped at ";	 Catch:{ all -> 0x017a }
        r0 = r16;	 Catch:{ all -> 0x017a }
        r0.print(r2);	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r2 = r0.mState;	 Catch:{ all -> 0x017a }
        r2 = stateToString(r2);	 Catch:{ all -> 0x017a }
        r0 = r16;	 Catch:{ all -> 0x017a }
        r0.println(r2);	 Catch:{ all -> 0x017a }
        r21.exitForceIdleLocked();	 Catch:{ all -> 0x017a }
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x017a }
        r2 = -1;
        monitor-exit(r21);
        return r2;
    L_0x0113:
        r0 = r21;	 Catch:{ all -> 0x017a }
        r11 = r0.mState;	 Catch:{ all -> 0x017a }
        goto L_0x00e4;	 Catch:{ all -> 0x017a }
    L_0x0118:
        r2 = "Now forced in to deep idle mode";	 Catch:{ all -> 0x017a }
        r0 = r16;	 Catch:{ all -> 0x017a }
        r0.println(r2);	 Catch:{ all -> 0x017a }
    L_0x0120:
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x017a }
        goto L_0x004e;
    L_0x0125:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x0128:
        r2 = "light";	 Catch:{ all -> 0x017a }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x017a }
        if (r2 == 0) goto L_0x017f;	 Catch:{ all -> 0x017a }
    L_0x0131:
        r2 = 1;	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r0.mForceIdle = r2;	 Catch:{ all -> 0x017a }
        r21.becomeInactiveIfAppropriateLocked();	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r10 = r0.mLightState;	 Catch:{ all -> 0x017a }
    L_0x013d:
        r2 = 4;	 Catch:{ all -> 0x017a }
        if (r10 == r2) goto L_0x0171;	 Catch:{ all -> 0x017a }
    L_0x0140:
        r2 = "s:shell";	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r0.stepIdleStateLocked(r2);	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r2 = r0.mLightState;	 Catch:{ all -> 0x017a }
        if (r10 != r2) goto L_0x016c;	 Catch:{ all -> 0x017a }
    L_0x014e:
        r2 = "Unable to go light idle; stopped at ";	 Catch:{ all -> 0x017a }
        r0 = r16;	 Catch:{ all -> 0x017a }
        r0.print(r2);	 Catch:{ all -> 0x017a }
        r0 = r21;	 Catch:{ all -> 0x017a }
        r2 = r0.mLightState;	 Catch:{ all -> 0x017a }
        r2 = lightStateToString(r2);	 Catch:{ all -> 0x017a }
        r0 = r16;	 Catch:{ all -> 0x017a }
        r0.println(r2);	 Catch:{ all -> 0x017a }
        r21.exitForceIdleLocked();	 Catch:{ all -> 0x017a }
        android.os.Binder.restoreCallingIdentity(r18);
        r2 = -1;
        monitor-exit(r21);
        return r2;
    L_0x016c:
        r0 = r21;	 Catch:{ all -> 0x017a }
        r10 = r0.mLightState;	 Catch:{ all -> 0x017a }
        goto L_0x013d;	 Catch:{ all -> 0x017a }
    L_0x0171:
        r2 = "Now forced in to light idle mode";	 Catch:{ all -> 0x017a }
        r0 = r16;	 Catch:{ all -> 0x017a }
        r0.println(r2);	 Catch:{ all -> 0x017a }
        goto L_0x0120;
    L_0x017a:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x017a }
        throw r2;	 Catch:{ all -> 0x017a }
    L_0x017f:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x017a }
        r2.<init>();	 Catch:{ all -> 0x017a }
        r4 = "Unknown idle mode: ";	 Catch:{ all -> 0x017a }
        r2 = r2.append(r4);	 Catch:{ all -> 0x017a }
        r2 = r2.append(r3);	 Catch:{ all -> 0x017a }
        r2 = r2.toString();	 Catch:{ all -> 0x017a }
        r0 = r16;	 Catch:{ all -> 0x017a }
        r0.println(r2);	 Catch:{ all -> 0x017a }
        goto L_0x0120;
    L_0x0199:
        r2 = "force-inactive";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x01f3;
    L_0x01a4:
        r2 = r21.getContext();
        r4 = "android.permission.DEVICE_POWER";
        r5 = 0;
        r2.enforceCallingOrSelfPermission(r4, r5);
        monitor-enter(r21);
        r18 = android.os.Binder.clearCallingIdentity();	 Catch:{ all -> 0x01ee }
        r2 = 1;
        r0 = r21;	 Catch:{ all -> 0x01ee }
        r0.mForceIdle = r2;	 Catch:{ all -> 0x01ee }
        r21.becomeInactiveIfAppropriateLocked();	 Catch:{ all -> 0x01ee }
        r2 = "Light state: ";	 Catch:{ all -> 0x01ee }
        r0 = r16;	 Catch:{ all -> 0x01ee }
        r0.print(r2);	 Catch:{ all -> 0x01ee }
        r0 = r21;	 Catch:{ all -> 0x01ee }
        r2 = r0.mLightState;	 Catch:{ all -> 0x01ee }
        r2 = lightStateToString(r2);	 Catch:{ all -> 0x01ee }
        r0 = r16;	 Catch:{ all -> 0x01ee }
        r0.print(r2);	 Catch:{ all -> 0x01ee }
        r2 = ", deep state: ";	 Catch:{ all -> 0x01ee }
        r0 = r16;	 Catch:{ all -> 0x01ee }
        r0.print(r2);	 Catch:{ all -> 0x01ee }
        r0 = r21;	 Catch:{ all -> 0x01ee }
        r2 = r0.mState;	 Catch:{ all -> 0x01ee }
        r2 = stateToString(r2);	 Catch:{ all -> 0x01ee }
        r0 = r16;	 Catch:{ all -> 0x01ee }
        r0.println(r2);	 Catch:{ all -> 0x01ee }
        android.os.Binder.restoreCallingIdentity(r18);
        goto L_0x004e;
    L_0x01eb:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x01ee:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x01ee }
        throw r2;	 Catch:{ all -> 0x01ee }
    L_0x01f3:
        r2 = "unforce";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x0248;
    L_0x01fe:
        r2 = r21.getContext();
        r4 = "android.permission.DEVICE_POWER";
        r5 = 0;
        r2.enforceCallingOrSelfPermission(r4, r5);
        monitor-enter(r21);
        r18 = android.os.Binder.clearCallingIdentity();	 Catch:{ all -> 0x0243 }
        r21.exitForceIdleLocked();	 Catch:{ all -> 0x0243 }
        r2 = "Light state: ";	 Catch:{ all -> 0x0243 }
        r0 = r16;	 Catch:{ all -> 0x0243 }
        r0.print(r2);	 Catch:{ all -> 0x0243 }
        r0 = r21;	 Catch:{ all -> 0x0243 }
        r2 = r0.mLightState;	 Catch:{ all -> 0x0243 }
        r2 = lightStateToString(r2);	 Catch:{ all -> 0x0243 }
        r0 = r16;	 Catch:{ all -> 0x0243 }
        r0.print(r2);	 Catch:{ all -> 0x0243 }
        r2 = ", deep state: ";	 Catch:{ all -> 0x0243 }
        r0 = r16;	 Catch:{ all -> 0x0243 }
        r0.print(r2);	 Catch:{ all -> 0x0243 }
        r0 = r21;	 Catch:{ all -> 0x0243 }
        r2 = r0.mState;	 Catch:{ all -> 0x0243 }
        r2 = stateToString(r2);	 Catch:{ all -> 0x0243 }
        r0 = r16;	 Catch:{ all -> 0x0243 }
        r0.println(r2);	 Catch:{ all -> 0x0243 }
        android.os.Binder.restoreCallingIdentity(r18);
        goto L_0x004e;
    L_0x0240:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x0243:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x0243 }
        throw r2;	 Catch:{ all -> 0x0243 }
    L_0x0248:
        r2 = "get";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x0314;
    L_0x0253:
        r2 = r21.getContext();
        r4 = "android.permission.DEVICE_POWER";
        r5 = 0;
        r2.enforceCallingOrSelfPermission(r4, r5);
        monitor-enter(r21);
        r3 = r22.getNextArg();	 Catch:{ all -> 0x029e }
        if (r3 == 0) goto L_0x030a;	 Catch:{ all -> 0x029e }
    L_0x0265:
        r18 = android.os.Binder.clearCallingIdentity();	 Catch:{ all -> 0x029e }
        r2 = "light";	 Catch:{ all -> 0x029e }
        r2 = r3.equals(r2);	 Catch:{ all -> 0x029e }
        if (r2 == 0) goto L_0x0287;	 Catch:{ all -> 0x029e }
    L_0x0272:
        r0 = r21;	 Catch:{ all -> 0x029e }
        r2 = r0.mLightState;	 Catch:{ all -> 0x029e }
        r2 = lightStateToString(r2);	 Catch:{ all -> 0x029e }
        r0 = r16;	 Catch:{ all -> 0x029e }
        r0.println(r2);	 Catch:{ all -> 0x029e }
    L_0x027f:
        android.os.Binder.restoreCallingIdentity(r18);
        goto L_0x004e;
    L_0x0284:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x0287:
        r2 = "deep";	 Catch:{ all -> 0x029e }
        r2 = r3.equals(r2);	 Catch:{ all -> 0x029e }
        if (r2 == 0) goto L_0x02a3;	 Catch:{ all -> 0x029e }
    L_0x0290:
        r0 = r21;	 Catch:{ all -> 0x029e }
        r2 = r0.mState;	 Catch:{ all -> 0x029e }
        r2 = stateToString(r2);	 Catch:{ all -> 0x029e }
        r0 = r16;	 Catch:{ all -> 0x029e }
        r0.println(r2);	 Catch:{ all -> 0x029e }
        goto L_0x027f;
    L_0x029e:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x029e }
        throw r2;	 Catch:{ all -> 0x029e }
    L_0x02a3:
        r2 = "force";	 Catch:{ all -> 0x029e }
        r2 = r3.equals(r2);	 Catch:{ all -> 0x029e }
        if (r2 == 0) goto L_0x02b6;	 Catch:{ all -> 0x029e }
    L_0x02ac:
        r0 = r21;	 Catch:{ all -> 0x029e }
        r2 = r0.mForceIdle;	 Catch:{ all -> 0x029e }
        r0 = r16;	 Catch:{ all -> 0x029e }
        r0.println(r2);	 Catch:{ all -> 0x029e }
        goto L_0x027f;	 Catch:{ all -> 0x029e }
    L_0x02b6:
        r2 = "screen";	 Catch:{ all -> 0x029e }
        r2 = r3.equals(r2);	 Catch:{ all -> 0x029e }
        if (r2 == 0) goto L_0x02c9;	 Catch:{ all -> 0x029e }
    L_0x02bf:
        r0 = r21;	 Catch:{ all -> 0x029e }
        r2 = r0.mScreenOn;	 Catch:{ all -> 0x029e }
        r0 = r16;	 Catch:{ all -> 0x029e }
        r0.println(r2);	 Catch:{ all -> 0x029e }
        goto L_0x027f;	 Catch:{ all -> 0x029e }
    L_0x02c9:
        r2 = "charging";	 Catch:{ all -> 0x029e }
        r2 = r3.equals(r2);	 Catch:{ all -> 0x029e }
        if (r2 == 0) goto L_0x02dc;	 Catch:{ all -> 0x029e }
    L_0x02d2:
        r0 = r21;	 Catch:{ all -> 0x029e }
        r2 = r0.mCharging;	 Catch:{ all -> 0x029e }
        r0 = r16;	 Catch:{ all -> 0x029e }
        r0.println(r2);	 Catch:{ all -> 0x029e }
        goto L_0x027f;	 Catch:{ all -> 0x029e }
    L_0x02dc:
        r2 = "network";	 Catch:{ all -> 0x029e }
        r2 = r3.equals(r2);	 Catch:{ all -> 0x029e }
        if (r2 == 0) goto L_0x02ef;	 Catch:{ all -> 0x029e }
    L_0x02e5:
        r0 = r21;	 Catch:{ all -> 0x029e }
        r2 = r0.mNetworkConnected;	 Catch:{ all -> 0x029e }
        r0 = r16;	 Catch:{ all -> 0x029e }
        r0.println(r2);	 Catch:{ all -> 0x029e }
        goto L_0x027f;	 Catch:{ all -> 0x029e }
    L_0x02ef:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x029e }
        r2.<init>();	 Catch:{ all -> 0x029e }
        r4 = "Unknown get option: ";	 Catch:{ all -> 0x029e }
        r2 = r2.append(r4);	 Catch:{ all -> 0x029e }
        r2 = r2.append(r3);	 Catch:{ all -> 0x029e }
        r2 = r2.toString();	 Catch:{ all -> 0x029e }
        r0 = r16;	 Catch:{ all -> 0x029e }
        r0.println(r2);	 Catch:{ all -> 0x029e }
        goto L_0x027f;
    L_0x030a:
        r2 = "Argument required";	 Catch:{ all -> 0x029e }
        r0 = r16;	 Catch:{ all -> 0x029e }
        r0.println(r2);	 Catch:{ all -> 0x029e }
        goto L_0x004e;
    L_0x0314:
        r2 = "disable";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x03d8;
    L_0x031f:
        r2 = r21.getContext();
        r4 = "android.permission.DEVICE_POWER";
        r5 = 0;
        r2.enforceCallingOrSelfPermission(r4, r5);
        monitor-enter(r21);
        r18 = android.os.Binder.clearCallingIdentity();	 Catch:{ all -> 0x03d3 }
        r3 = r22.getNextArg();	 Catch:{ all -> 0x03d3 }
        r8 = 0;
        r20 = 0;
        if (r3 == 0) goto L_0x034a;
    L_0x0338:
        r2 = "deep";	 Catch:{ all -> 0x03d3 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x03d3 }
        if (r2 != 0) goto L_0x034a;	 Catch:{ all -> 0x03d3 }
    L_0x0341:
        r2 = "all";	 Catch:{ all -> 0x03d3 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x03d3 }
        if (r2 == 0) goto L_0x0360;	 Catch:{ all -> 0x03d3 }
    L_0x034a:
        r20 = 1;	 Catch:{ all -> 0x03d3 }
        r0 = r21;	 Catch:{ all -> 0x03d3 }
        r2 = r0.mDeepEnabled;	 Catch:{ all -> 0x03d3 }
        if (r2 == 0) goto L_0x0360;	 Catch:{ all -> 0x03d3 }
    L_0x0352:
        r2 = 0;	 Catch:{ all -> 0x03d3 }
        r0 = r21;	 Catch:{ all -> 0x03d3 }
        r0.mDeepEnabled = r2;	 Catch:{ all -> 0x03d3 }
        r8 = 1;	 Catch:{ all -> 0x03d3 }
        r2 = "Deep idle mode disabled";	 Catch:{ all -> 0x03d3 }
        r0 = r16;	 Catch:{ all -> 0x03d3 }
        r0.println(r2);	 Catch:{ all -> 0x03d3 }
    L_0x0360:
        if (r3 == 0) goto L_0x0374;	 Catch:{ all -> 0x03d3 }
    L_0x0362:
        r2 = "light";	 Catch:{ all -> 0x03d3 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x03d3 }
        if (r2 != 0) goto L_0x0374;	 Catch:{ all -> 0x03d3 }
    L_0x036b:
        r2 = "all";	 Catch:{ all -> 0x03d3 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x03d3 }
        if (r2 == 0) goto L_0x038a;	 Catch:{ all -> 0x03d3 }
    L_0x0374:
        r20 = 1;	 Catch:{ all -> 0x03d3 }
        r0 = r21;	 Catch:{ all -> 0x03d3 }
        r2 = r0.mLightEnabled;	 Catch:{ all -> 0x03d3 }
        if (r2 == 0) goto L_0x038a;	 Catch:{ all -> 0x03d3 }
    L_0x037c:
        r2 = 0;	 Catch:{ all -> 0x03d3 }
        r0 = r21;	 Catch:{ all -> 0x03d3 }
        r0.mLightEnabled = r2;	 Catch:{ all -> 0x03d3 }
        r8 = 1;	 Catch:{ all -> 0x03d3 }
        r2 = "Light idle mode disabled";	 Catch:{ all -> 0x03d3 }
        r0 = r16;	 Catch:{ all -> 0x03d3 }
        r0.println(r2);	 Catch:{ all -> 0x03d3 }
    L_0x038a:
        if (r8 == 0) goto L_0x03ae;	 Catch:{ all -> 0x03d3 }
    L_0x038c:
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x03d3 }
        r4.<init>();	 Catch:{ all -> 0x03d3 }
        if (r3 != 0) goto L_0x03d1;	 Catch:{ all -> 0x03d3 }
    L_0x0393:
        r2 = "all";	 Catch:{ all -> 0x03d3 }
    L_0x0396:
        r2 = r4.append(r2);	 Catch:{ all -> 0x03d3 }
        r4 = "-disabled";	 Catch:{ all -> 0x03d3 }
        r2 = r2.append(r4);	 Catch:{ all -> 0x03d3 }
        r2 = r2.toString();	 Catch:{ all -> 0x03d3 }
        r4 = android.os.Process.myUid();	 Catch:{ all -> 0x03d3 }
        r0 = r21;	 Catch:{ all -> 0x03d3 }
        r0.becomeActiveLocked(r2, r4);	 Catch:{ all -> 0x03d3 }
    L_0x03ae:
        if (r20 != 0) goto L_0x03c9;	 Catch:{ all -> 0x03d3 }
    L_0x03b0:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x03d3 }
        r2.<init>();	 Catch:{ all -> 0x03d3 }
        r4 = "Unknown idle mode: ";	 Catch:{ all -> 0x03d3 }
        r2 = r2.append(r4);	 Catch:{ all -> 0x03d3 }
        r2 = r2.append(r3);	 Catch:{ all -> 0x03d3 }
        r2 = r2.toString();	 Catch:{ all -> 0x03d3 }
        r0 = r16;	 Catch:{ all -> 0x03d3 }
        r0.println(r2);	 Catch:{ all -> 0x03d3 }
    L_0x03c9:
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x03d3 }
        goto L_0x004e;
    L_0x03ce:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x03d1:
        r2 = r3;
        goto L_0x0396;
    L_0x03d3:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x03d3 }
        throw r2;	 Catch:{ all -> 0x03d3 }
    L_0x03d8:
        r2 = "enable";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x047b;
    L_0x03e3:
        r2 = r21.getContext();
        r4 = "android.permission.DEVICE_POWER";
        r5 = 0;
        r2.enforceCallingOrSelfPermission(r4, r5);
        monitor-enter(r21);
        r18 = android.os.Binder.clearCallingIdentity();	 Catch:{ all -> 0x0476 }
        r3 = r22.getNextArg();	 Catch:{ all -> 0x0476 }
        r9 = 0;
        r20 = 0;
        if (r3 == 0) goto L_0x040e;
    L_0x03fc:
        r2 = "deep";	 Catch:{ all -> 0x0476 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x0476 }
        if (r2 != 0) goto L_0x040e;	 Catch:{ all -> 0x0476 }
    L_0x0405:
        r2 = "all";	 Catch:{ all -> 0x0476 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x0476 }
        if (r2 == 0) goto L_0x0424;	 Catch:{ all -> 0x0476 }
    L_0x040e:
        r20 = 1;	 Catch:{ all -> 0x0476 }
        r0 = r21;	 Catch:{ all -> 0x0476 }
        r2 = r0.mDeepEnabled;	 Catch:{ all -> 0x0476 }
        if (r2 != 0) goto L_0x0424;	 Catch:{ all -> 0x0476 }
    L_0x0416:
        r2 = 1;	 Catch:{ all -> 0x0476 }
        r0 = r21;	 Catch:{ all -> 0x0476 }
        r0.mDeepEnabled = r2;	 Catch:{ all -> 0x0476 }
        r9 = 1;	 Catch:{ all -> 0x0476 }
        r2 = "Deep idle mode enabled";	 Catch:{ all -> 0x0476 }
        r0 = r16;	 Catch:{ all -> 0x0476 }
        r0.println(r2);	 Catch:{ all -> 0x0476 }
    L_0x0424:
        if (r3 == 0) goto L_0x0438;	 Catch:{ all -> 0x0476 }
    L_0x0426:
        r2 = "light";	 Catch:{ all -> 0x0476 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x0476 }
        if (r2 != 0) goto L_0x0438;	 Catch:{ all -> 0x0476 }
    L_0x042f:
        r2 = "all";	 Catch:{ all -> 0x0476 }
        r2 = r2.equals(r3);	 Catch:{ all -> 0x0476 }
        if (r2 == 0) goto L_0x044e;	 Catch:{ all -> 0x0476 }
    L_0x0438:
        r20 = 1;	 Catch:{ all -> 0x0476 }
        r0 = r21;	 Catch:{ all -> 0x0476 }
        r2 = r0.mLightEnabled;	 Catch:{ all -> 0x0476 }
        if (r2 != 0) goto L_0x044e;	 Catch:{ all -> 0x0476 }
    L_0x0440:
        r2 = 1;	 Catch:{ all -> 0x0476 }
        r0 = r21;	 Catch:{ all -> 0x0476 }
        r0.mLightEnabled = r2;	 Catch:{ all -> 0x0476 }
        r9 = 1;	 Catch:{ all -> 0x0476 }
        r2 = "Light idle mode enable";	 Catch:{ all -> 0x0476 }
        r0 = r16;	 Catch:{ all -> 0x0476 }
        r0.println(r2);	 Catch:{ all -> 0x0476 }
    L_0x044e:
        if (r9 == 0) goto L_0x0453;	 Catch:{ all -> 0x0476 }
    L_0x0450:
        r21.becomeInactiveIfAppropriateLocked();	 Catch:{ all -> 0x0476 }
    L_0x0453:
        if (r20 != 0) goto L_0x046e;	 Catch:{ all -> 0x0476 }
    L_0x0455:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x0476 }
        r2.<init>();	 Catch:{ all -> 0x0476 }
        r4 = "Unknown idle mode: ";	 Catch:{ all -> 0x0476 }
        r2 = r2.append(r4);	 Catch:{ all -> 0x0476 }
        r2 = r2.append(r3);	 Catch:{ all -> 0x0476 }
        r2 = r2.toString();	 Catch:{ all -> 0x0476 }
        r0 = r16;	 Catch:{ all -> 0x0476 }
        r0.println(r2);	 Catch:{ all -> 0x0476 }
    L_0x046e:
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x0476 }
        goto L_0x004e;
    L_0x0473:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x0476:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x0476 }
        throw r2;	 Catch:{ all -> 0x0476 }
    L_0x047b:
        r2 = "enabled";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x050e;
    L_0x0486:
        monitor-enter(r21);
        r3 = r22.getNextArg();
        if (r3 == 0) goto L_0x0496;
    L_0x048d:
        r2 = "all";
        r2 = r2.equals(r3);
        if (r2 == 0) goto L_0x04b5;
    L_0x0496:
        r0 = r21;
        r2 = r0.mDeepEnabled;
        if (r2 == 0) goto L_0x04af;
    L_0x049c:
        r0 = r21;
        r2 = r0.mLightEnabled;
        if (r2 == 0) goto L_0x04af;
    L_0x04a2:
        r2 = "1";
    L_0x04a5:
        r0 = r16;
        r0.println(r2);
        goto L_0x004e;
    L_0x04ac:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x04af:
        r2 = 0;
        r2 = java.lang.Integer.valueOf(r2);
        goto L_0x04a5;
    L_0x04b5:
        r2 = "deep";
        r2 = r2.equals(r3);
        if (r2 == 0) goto L_0x04d4;
    L_0x04be:
        r0 = r21;
        r2 = r0.mDeepEnabled;
        if (r2 == 0) goto L_0x04ce;
    L_0x04c4:
        r2 = "1";
    L_0x04c7:
        r0 = r16;
        r0.println(r2);
        goto L_0x004e;
    L_0x04ce:
        r2 = 0;
        r2 = java.lang.Integer.valueOf(r2);
        goto L_0x04c7;
    L_0x04d4:
        r2 = "light";
        r2 = r2.equals(r3);
        if (r2 == 0) goto L_0x04f3;
    L_0x04dd:
        r0 = r21;
        r2 = r0.mLightEnabled;
        if (r2 == 0) goto L_0x04ed;
    L_0x04e3:
        r2 = "1";
    L_0x04e6:
        r0 = r16;
        r0.println(r2);
        goto L_0x004e;
    L_0x04ed:
        r2 = 0;
        r2 = java.lang.Integer.valueOf(r2);
        goto L_0x04e6;
    L_0x04f3:
        r2 = new java.lang.StringBuilder;
        r2.<init>();
        r4 = "Unknown idle mode: ";
        r2 = r2.append(r4);
        r2 = r2.append(r3);
        r2 = r2.toString();
        r0 = r16;
        r0.println(r2);
        goto L_0x004e;
    L_0x050e:
        r2 = "whitelist";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x06b9;
    L_0x0519:
        r3 = r22.getNextArg();
        if (r3 == 0) goto L_0x05f9;
    L_0x051f:
        r2 = r21.getContext();
        r4 = "android.permission.DEVICE_POWER";
        r5 = 0;
        r2.enforceCallingOrSelfPermission(r4, r5);
        r18 = android.os.Binder.clearCallingIdentity();
    L_0x052e:
        r2 = r3.length();	 Catch:{ all -> 0x05c2 }
        r4 = 1;	 Catch:{ all -> 0x05c2 }
        if (r2 < r4) goto L_0x0550;	 Catch:{ all -> 0x05c2 }
    L_0x0535:
        r2 = 0;	 Catch:{ all -> 0x05c2 }
        r2 = r3.charAt(r2);	 Catch:{ all -> 0x05c2 }
        r4 = 45;	 Catch:{ all -> 0x05c2 }
        if (r2 == r4) goto L_0x056e;	 Catch:{ all -> 0x05c2 }
    L_0x053e:
        r2 = 0;	 Catch:{ all -> 0x05c2 }
        r2 = r3.charAt(r2);	 Catch:{ all -> 0x05c2 }
        r4 = 43;	 Catch:{ all -> 0x05c2 }
        if (r2 == r4) goto L_0x056e;	 Catch:{ all -> 0x05c2 }
    L_0x0547:
        r2 = 0;	 Catch:{ all -> 0x05c2 }
        r2 = r3.charAt(r2);	 Catch:{ all -> 0x05c2 }
        r4 = 61;	 Catch:{ all -> 0x05c2 }
        if (r2 == r4) goto L_0x056e;	 Catch:{ all -> 0x05c2 }
    L_0x0550:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x05c2 }
        r2.<init>();	 Catch:{ all -> 0x05c2 }
        r4 = "Package must be prefixed with +, -, or =: ";	 Catch:{ all -> 0x05c2 }
        r2 = r2.append(r4);	 Catch:{ all -> 0x05c2 }
        r2 = r2.append(r3);	 Catch:{ all -> 0x05c2 }
        r2 = r2.toString();	 Catch:{ all -> 0x05c2 }
        r0 = r16;	 Catch:{ all -> 0x05c2 }
        r0.println(r2);	 Catch:{ all -> 0x05c2 }
        r2 = -1;
        android.os.Binder.restoreCallingIdentity(r18);
        return r2;
    L_0x056e:
        r2 = 0;
        r13 = r3.charAt(r2);	 Catch:{ all -> 0x05c2 }
        r2 = 1;	 Catch:{ all -> 0x05c2 }
        r15 = r3.substring(r2);	 Catch:{ all -> 0x05c2 }
        r2 = 43;	 Catch:{ all -> 0x05c2 }
        if (r13 != r2) goto L_0x05c7;	 Catch:{ all -> 0x05c2 }
    L_0x057c:
        r0 = r21;	 Catch:{ all -> 0x05c2 }
        r2 = r0.addPowerSaveWhitelistAppInternal(r15);	 Catch:{ all -> 0x05c2 }
        if (r2 == 0) goto L_0x05a8;	 Catch:{ all -> 0x05c2 }
    L_0x0584:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x05c2 }
        r2.<init>();	 Catch:{ all -> 0x05c2 }
        r4 = "Added: ";	 Catch:{ all -> 0x05c2 }
        r2 = r2.append(r4);	 Catch:{ all -> 0x05c2 }
        r2 = r2.append(r15);	 Catch:{ all -> 0x05c2 }
        r2 = r2.toString();	 Catch:{ all -> 0x05c2 }
        r0 = r16;	 Catch:{ all -> 0x05c2 }
        r0.println(r2);	 Catch:{ all -> 0x05c2 }
    L_0x059d:
        r3 = r22.getNextArg();	 Catch:{ all -> 0x05c2 }
        if (r3 != 0) goto L_0x052e;
    L_0x05a3:
        android.os.Binder.restoreCallingIdentity(r18);
        goto L_0x004f;
    L_0x05a8:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x05c2 }
        r2.<init>();	 Catch:{ all -> 0x05c2 }
        r4 = "Unknown package: ";	 Catch:{ all -> 0x05c2 }
        r2 = r2.append(r4);	 Catch:{ all -> 0x05c2 }
        r2 = r2.append(r15);	 Catch:{ all -> 0x05c2 }
        r2 = r2.toString();	 Catch:{ all -> 0x05c2 }
        r0 = r16;	 Catch:{ all -> 0x05c2 }
        r0.println(r2);	 Catch:{ all -> 0x05c2 }
        goto L_0x059d;
    L_0x05c2:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);
        throw r2;
    L_0x05c7:
        r2 = 45;
        if (r13 != r2) goto L_0x05ed;
    L_0x05cb:
        r0 = r21;	 Catch:{ all -> 0x05c2 }
        r2 = r0.removePowerSaveWhitelistAppInternal(r15);	 Catch:{ all -> 0x05c2 }
        if (r2 == 0) goto L_0x059d;	 Catch:{ all -> 0x05c2 }
    L_0x05d3:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x05c2 }
        r2.<init>();	 Catch:{ all -> 0x05c2 }
        r4 = "Removed: ";	 Catch:{ all -> 0x05c2 }
        r2 = r2.append(r4);	 Catch:{ all -> 0x05c2 }
        r2 = r2.append(r15);	 Catch:{ all -> 0x05c2 }
        r2 = r2.toString();	 Catch:{ all -> 0x05c2 }
        r0 = r16;	 Catch:{ all -> 0x05c2 }
        r0.println(r2);	 Catch:{ all -> 0x05c2 }
        goto L_0x059d;	 Catch:{ all -> 0x05c2 }
    L_0x05ed:
        r0 = r21;	 Catch:{ all -> 0x05c2 }
        r2 = r0.getPowerSaveWhitelistAppInternal(r15);	 Catch:{ all -> 0x05c2 }
        r0 = r16;	 Catch:{ all -> 0x05c2 }
        r0.println(r2);	 Catch:{ all -> 0x05c2 }
        goto L_0x059d;
    L_0x05f9:
        monitor-enter(r21);
        r18 = android.os.Binder.clearCallingIdentity();	 Catch:{ all -> 0x06b4 }
        r12 = 0;
    L_0x05ff:
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistAppsExceptIdle;	 Catch:{ all -> 0x06b4 }
        r2 = r2.size();	 Catch:{ all -> 0x06b4 }
        if (r12 >= r2) goto L_0x0638;	 Catch:{ all -> 0x06b4 }
    L_0x0609:
        r2 = "system-excidle,";	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistAppsExceptIdle;	 Catch:{ all -> 0x06b4 }
        r2 = r2.keyAt(r12);	 Catch:{ all -> 0x06b4 }
        r2 = (java.lang.String) r2;	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r2 = ",";	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistAppsExceptIdle;	 Catch:{ all -> 0x06b4 }
        r2 = r2.valueAt(r12);	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.println(r2);	 Catch:{ all -> 0x06b4 }
        r12 = r12 + 1;	 Catch:{ all -> 0x06b4 }
        goto L_0x05ff;	 Catch:{ all -> 0x06b4 }
    L_0x0638:
        r12 = 0;	 Catch:{ all -> 0x06b4 }
    L_0x0639:
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistApps;	 Catch:{ all -> 0x06b4 }
        r2 = r2.size();	 Catch:{ all -> 0x06b4 }
        if (r12 >= r2) goto L_0x0672;	 Catch:{ all -> 0x06b4 }
    L_0x0643:
        r2 = "system,";	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistApps;	 Catch:{ all -> 0x06b4 }
        r2 = r2.keyAt(r12);	 Catch:{ all -> 0x06b4 }
        r2 = (java.lang.String) r2;	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r2 = ",";	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistApps;	 Catch:{ all -> 0x06b4 }
        r2 = r2.valueAt(r12);	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.println(r2);	 Catch:{ all -> 0x06b4 }
        r12 = r12 + 1;	 Catch:{ all -> 0x06b4 }
        goto L_0x0639;	 Catch:{ all -> 0x06b4 }
    L_0x0672:
        r12 = 0;	 Catch:{ all -> 0x06b4 }
    L_0x0673:
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistUserApps;	 Catch:{ all -> 0x06b4 }
        r2 = r2.size();	 Catch:{ all -> 0x06b4 }
        if (r12 >= r2) goto L_0x06ac;	 Catch:{ all -> 0x06b4 }
    L_0x067d:
        r2 = "user,";	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistUserApps;	 Catch:{ all -> 0x06b4 }
        r2 = r2.keyAt(r12);	 Catch:{ all -> 0x06b4 }
        r2 = (java.lang.String) r2;	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r2 = ",";	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.print(r2);	 Catch:{ all -> 0x06b4 }
        r0 = r21;	 Catch:{ all -> 0x06b4 }
        r2 = r0.mPowerSaveWhitelistUserApps;	 Catch:{ all -> 0x06b4 }
        r2 = r2.valueAt(r12);	 Catch:{ all -> 0x06b4 }
        r0 = r16;	 Catch:{ all -> 0x06b4 }
        r0.println(r2);	 Catch:{ all -> 0x06b4 }
        r12 = r12 + 1;
        goto L_0x0673;
    L_0x06ac:
        android.os.Binder.restoreCallingIdentity(r18);
        goto L_0x004e;
    L_0x06b1:
        r2 = move-exception;
        monitor-exit(r21);
        throw r2;
    L_0x06b4:
        r2 = move-exception;
        android.os.Binder.restoreCallingIdentity(r18);	 Catch:{ all -> 0x06b4 }
        throw r2;	 Catch:{ all -> 0x06b4 }
    L_0x06b9:
        r2 = "tempwhitelist";
        r0 = r23;
        r2 = r2.equals(r0);
        if (r2 == 0) goto L_0x072a;
    L_0x06c4:
        r14 = r22.getNextOption();
        if (r14 == 0) goto L_0x06ec;
    L_0x06ca:
        r2 = "-u";
        r2 = r2.equals(r14);
        if (r2 == 0) goto L_0x06c4;
    L_0x06d3:
        r14 = r22.getNextArg();
        if (r14 != 0) goto L_0x06e3;
    L_0x06d9:
        r2 = "-u requires a user number";
        r0 = r16;
        r0.println(r2);
        r2 = -1;
        return r2;
    L_0x06e3:
        r2 = java.lang.Integer.parseInt(r14);
        r0 = r22;
        r0.userId = r2;
        goto L_0x06c4;
    L_0x06ec:
        r3 = r22.getNextArg();
        if (r3 == 0) goto L_0x0720;
    L_0x06f2:
        r0 = r22;	 Catch:{ RemoteException -> 0x0702 }
        r6 = r0.userId;	 Catch:{ RemoteException -> 0x0702 }
        r7 = "shell";	 Catch:{ RemoteException -> 0x0702 }
        r4 = 10000; // 0x2710 float:1.4013E-41 double:4.9407E-320;	 Catch:{ RemoteException -> 0x0702 }
        r2 = r21;	 Catch:{ RemoteException -> 0x0702 }
        r2.addPowerSaveTempWhitelistAppChecked(r3, r4, r6, r7);	 Catch:{ RemoteException -> 0x0702 }
        goto L_0x004f;
    L_0x0702:
        r17 = move-exception;
        r2 = new java.lang.StringBuilder;
        r2.<init>();
        r4 = "Failed: ";
        r2 = r2.append(r4);
        r0 = r17;
        r2 = r2.append(r0);
        r2 = r2.toString();
        r0 = r16;
        r0.println(r2);
        goto L_0x004f;
    L_0x0720:
        r2 = 0;
        r0 = r21;
        r1 = r16;
        r0.dumpTempWhitelistSchedule(r1, r2);
        goto L_0x004f;
    L_0x072a:
        r2 = r22.handleDefaultCommands(r23);
        return r2;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.DeviceIdleController.onShellCommand(com.android.server.DeviceIdleController$Shell, java.lang.String):int");
    }

    static {
        boolean isLoggable = !Log.HWINFO ? Log.HWModuleLog ? Log.isLoggable(TAG, 4) : false : true;
        DEBUG = isLoggable;
    }

    private static String stateToString(int state) {
        switch (state) {
            case 0:
                return "ACTIVE";
            case 1:
                return "INACTIVE";
            case 2:
                return "IDLE_PENDING";
            case 3:
                return "SENSING";
            case 4:
                return "LOCATING";
            case 5:
                return "IDLE";
            case 6:
                return "IDLE_MAINTENANCE";
            default:
                return Integer.toString(state);
        }
    }

    private static String lightStateToString(int state) {
        switch (state) {
            case 0:
                return "ACTIVE";
            case 1:
                return "INACTIVE";
            case 3:
                return "PRE_IDLE";
            case 4:
                return "IDLE";
            case 5:
                return "WAITING_FOR_NETWORK";
            case 6:
                return "IDLE_MAINTENANCE";
            case 7:
                return "OVERRIDE";
            default:
                return Integer.toString(state);
        }
    }

    private void addEvent(int cmd) {
        if (this.mEventCmds[0] != cmd) {
            System.arraycopy(this.mEventCmds, 0, this.mEventCmds, 1, 99);
            System.arraycopy(this.mEventTimes, 0, this.mEventTimes, 1, 99);
            this.mEventCmds[0] = cmd;
            this.mEventTimes[0] = SystemClock.elapsedRealtime();
        }
    }

    public void onAnyMotionResult(int result) {
        if (DEBUG) {
            Slog.d(TAG, "onAnyMotionResult(" + result + ")");
        }
        if (result != -1) {
            synchronized (this) {
                cancelSensingTimeoutAlarmLocked();
            }
        }
        if (result == 1) {
            if (DEBUG) {
                Slog.d(TAG, "RESULT_MOVED received.");
            }
            synchronized (this) {
                handleMotionDetectedLocked(this.mConstants.INACTIVE_TIMEOUT, "sense_motion");
            }
        } else if (result == 0) {
            if (DEBUG) {
                Slog.d(TAG, "RESULT_STATIONARY received.");
            }
            if (this.mState == 3) {
                synchronized (this) {
                    this.mNotMoving = true;
                    stepIdleStateLocked("s:stationary");
                }
            } else if (this.mState == 4) {
                synchronized (this) {
                    this.mNotMoving = true;
                    if (this.mLocated) {
                        stepIdleStateLocked("s:stationary");
                    }
                }
            } else {
                return;
            }
        } else {
            return;
        }
    }

    public DeviceIdleController(Context context) {
        super(context);
    }

    int[] getPowerSaveWhitelistUserAppIds() {
        int[] iArr;
        synchronized (this) {
            iArr = this.mPowerSaveWhitelistUserAppIdArray;
        }
        return iArr;
    }

    private static File getSystemDir() {
        return new File(Environment.getDataDirectory(), "system");
    }

    public void onStart() {
        PackageManager pm = getContext().getPackageManager();
        synchronized (this) {
            int i;
            boolean z = getContext().getResources().getBoolean(17956883);
            this.mDeepEnabled = z;
            this.mLightEnabled = z;
            SystemConfig sysConfig = SystemConfig.getInstance();
            ArraySet<String> allowPowerExceptIdle = sysConfig.getAllowInPowerSaveExceptIdle();
            for (i = 0; i < allowPowerExceptIdle.size(); i++) {
                try {
                    ApplicationInfo ai = pm.getApplicationInfo((String) allowPowerExceptIdle.valueAt(i), DumpState.DUMP_DEXOPT);
                    int appid = UserHandle.getAppId(ai.uid);
                    this.mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName, Integer.valueOf(appid));
                    this.mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid, true);
                } catch (NameNotFoundException e) {
                }
            }
            ArraySet<String> allowPower = sysConfig.getAllowInPowerSave();
            for (i = 0; i < allowPower.size(); i++) {
                try {
                    ai = pm.getApplicationInfo((String) allowPower.valueAt(i), DumpState.DUMP_DEXOPT);
                    appid = UserHandle.getAppId(ai.uid);
                    this.mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName, Integer.valueOf(appid));
                    this.mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid, true);
                    this.mPowerSaveWhitelistApps.put(ai.packageName, Integer.valueOf(appid));
                    this.mPowerSaveWhitelistSystemAppIds.put(appid, true);
                } catch (NameNotFoundException e2) {
                }
            }
            this.mConstants = new Constants(this.mHandler, getContext().getContentResolver());
            this.mNetworkConnected = true;
            this.mScreenOn = true;
            this.mCharging = true;
            this.mState = 0;
            this.mLightState = 0;
            this.mInactiveTimeout = this.mConstants.INACTIVE_TIMEOUT;
        }
        this.mBinderService = new BinderService();
        publishBinderService("deviceidle", this.mBinderService);
        publishLocalService(LocalService.class, new LocalService());
    }

    public void onBootPhase(int phase) {
        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
            synchronized (this) {
                this.mAlarmManager = (AlarmManager) getContext().getSystemService("alarm");
                this.mBatteryStats = BatteryStatsService.getService();
                this.mLocalPowerManager = (PowerManagerInternal) getLocalService(PowerManagerInternal.class);
                this.mPowerManager = (PowerManager) getContext().getSystemService(PowerManager.class);
                this.mActiveIdleWakeLock = this.mPowerManager.newWakeLock(1, "deviceidle_maint");
                this.mActiveIdleWakeLock.setReferenceCounted(false);
                this.mConnectivityService = (ConnectivityService) ServiceManager.getService("connectivity");
                this.mLocalAlarmManager = (com.android.server.AlarmManagerService.LocalService) getLocalService(com.android.server.AlarmManagerService.LocalService.class);
                this.mNetworkPolicyManager = INetworkPolicyManager.Stub.asInterface(ServiceManager.getService("netpolicy"));
                this.mDisplayManager = (DisplayManager) getContext().getSystemService("display");
                this.mSensorManager = (SensorManager) getContext().getSystemService("sensor");
                int sigMotionSensorId = getContext().getResources().getInteger(17694733);
                if (sigMotionSensorId > 0) {
                    this.mMotionSensor = this.mSensorManager.getDefaultSensor(sigMotionSensorId, true);
                }
                if (this.mMotionSensor == null && getContext().getResources().getBoolean(17956884)) {
                    this.mMotionSensor = this.mSensorManager.getDefaultSensor(26, true);
                }
                if (this.mMotionSensor == null) {
                    this.mMotionSensor = this.mSensorManager.getDefaultSensor(17, true);
                }
                if (getContext().getResources().getBoolean(17956885)) {
                    this.mLocationManager = (LocationManager) getContext().getSystemService("location");
                    this.mLocationRequest = new LocationRequest().setQuality(100).setInterval(0).setFastestInterval(0).setNumUpdates(1);
                }
                this.mAnyMotionDetector = new AnyMotionDetector((PowerManager) getContext().getSystemService("power"), this.mHandler, this.mSensorManager, this, ((float) getContext().getResources().getInteger(17694732)) / 100.0f);
                this.mIdleIntent = new Intent("android.os.action.DEVICE_IDLE_MODE_CHANGED");
                this.mIdleIntent.addFlags(1342177280);
                this.mLightIdleIntent = new Intent("android.os.action.LIGHT_DEVICE_IDLE_MODE_CHANGED");
                this.mLightIdleIntent.addFlags(1342177280);
                IntentFilter filter = new IntentFilter();
                filter.addAction("android.intent.action.BATTERY_CHANGED");
                getContext().registerReceiver(this.mReceiver, filter);
                filter = new IntentFilter();
                filter.addAction("android.intent.action.PACKAGE_REMOVED");
                filter.addDataScheme(HwBroadcastRadarUtil.KEY_PACKAGE);
                getContext().registerReceiver(this.mReceiver, filter);
                filter = new IntentFilter();
                filter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
                getContext().registerReceiver(this.mReceiver, filter);
                this.mLocalPowerManager.setDeviceIdleWhitelist(this.mPowerSaveWhitelistAllAppIdArray);
                this.mLocalAlarmManager.setDeviceIdleUserWhitelist(this.mPowerSaveWhitelistUserAppIdArray);
                this.mDisplayManager.registerDisplayListener(this.mDisplayListener, null);
                updateDisplayLocked();
            }
            updateConnectivityState(null);
        } else if (phase == 1000) {
            Slog.d(TAG, "PHASE_BOOT_COMPLETED");
            this.mHandler.postDelayed(new Runnable() {
                private static final int MAX_TRY_TIMES = 3;
                private int count = 0;

                public void run() {
                    this.count++;
                    if (!DeviceIdleController.this.updateWhitelistFromDB(this.count >= 3) && this.count < 3) {
                        DeviceIdleController.this.mHandler.postDelayed(this, JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
                    }
                }
            }, JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
        }
    }

    public boolean addPowerSaveWhitelistAppInternal(String name) {
        synchronized (this) {
            try {
                if (this.mPowerSaveWhitelistUserApps.put(name, Integer.valueOf(UserHandle.getAppId(getContext().getPackageManager().getApplicationInfo(name, DumpState.DUMP_PREFERRED_XML).uid))) == null) {
                    reportPowerSaveWhitelistChangedLocked();
                    updateWhitelistAppIdsLocked();
                    writeConfigFileLocked();
                }
            } catch (NameNotFoundException e) {
                return false;
            }
        }
        return true;
    }

    public boolean removePowerSaveWhitelistAppInternal(String name) {
        synchronized (this) {
            if (this.mPowerSaveWhitelistUserApps.remove(name) != null) {
                reportPowerSaveWhitelistChangedLocked();
                updateWhitelistAppIdsLocked();
                writeConfigFileLocked();
                return true;
            }
            return false;
        }
    }

    public boolean getPowerSaveWhitelistAppInternal(String name) {
        boolean containsKey;
        synchronized (this) {
            containsKey = this.mPowerSaveWhitelistUserApps.containsKey(name);
        }
        return containsKey;
    }

    public String[] getSystemPowerWhitelistExceptIdleInternal() {
        String[] apps;
        synchronized (this) {
            int size = this.mPowerSaveWhitelistAppsExceptIdle.size();
            apps = new String[size];
            for (int i = 0; i < size; i++) {
                apps[i] = (String) this.mPowerSaveWhitelistAppsExceptIdle.keyAt(i);
            }
        }
        return apps;
    }

    public String[] getSystemPowerWhitelistInternal() {
        String[] apps;
        synchronized (this) {
            int size = this.mPowerSaveWhitelistApps.size();
            apps = new String[size];
            for (int i = 0; i < size; i++) {
                apps[i] = (String) this.mPowerSaveWhitelistApps.keyAt(i);
            }
        }
        return apps;
    }

    public String[] getUserPowerWhitelistInternal() {
        String[] apps;
        synchronized (this) {
            apps = new String[this.mPowerSaveWhitelistUserApps.size()];
            for (int i = 0; i < this.mPowerSaveWhitelistUserApps.size(); i++) {
                apps[i] = (String) this.mPowerSaveWhitelistUserApps.keyAt(i);
            }
        }
        return apps;
    }

    public String[] getFullPowerWhitelistExceptIdleInternal() {
        String[] apps;
        synchronized (this) {
            int i;
            apps = new String[(this.mPowerSaveWhitelistAppsExceptIdle.size() + this.mPowerSaveWhitelistUserApps.size())];
            int cur = 0;
            for (i = 0; i < this.mPowerSaveWhitelistAppsExceptIdle.size(); i++) {
                apps[cur] = (String) this.mPowerSaveWhitelistAppsExceptIdle.keyAt(i);
                cur++;
            }
            for (i = 0; i < this.mPowerSaveWhitelistUserApps.size(); i++) {
                apps[cur] = (String) this.mPowerSaveWhitelistUserApps.keyAt(i);
                cur++;
            }
        }
        return apps;
    }

    public String[] getFullPowerWhitelistInternal() {
        String[] apps;
        synchronized (this) {
            int i;
            apps = new String[(this.mPowerSaveWhitelistApps.size() + this.mPowerSaveWhitelistUserApps.size())];
            int cur = 0;
            for (i = 0; i < this.mPowerSaveWhitelistApps.size(); i++) {
                apps[cur] = (String) this.mPowerSaveWhitelistApps.keyAt(i);
                cur++;
            }
            for (i = 0; i < this.mPowerSaveWhitelistUserApps.size(); i++) {
                apps[cur] = (String) this.mPowerSaveWhitelistUserApps.keyAt(i);
                cur++;
            }
        }
        return apps;
    }

    public boolean isPowerSaveWhitelistExceptIdleAppInternal(String packageName) {
        boolean z;
        synchronized (this) {
            if (this.mPowerSaveWhitelistAppsExceptIdle.containsKey(packageName)) {
                z = true;
            } else {
                z = this.mPowerSaveWhitelistUserApps.containsKey(packageName);
            }
        }
        return z;
    }

    public boolean isPowerSaveWhitelistAppInternal(String packageName) {
        boolean z;
        synchronized (this) {
            if (this.mPowerSaveWhitelistApps.containsKey(packageName)) {
                z = true;
            } else {
                z = this.mPowerSaveWhitelistUserApps.containsKey(packageName);
            }
        }
        return z;
    }

    public int[] getAppIdWhitelistExceptIdleInternal() {
        int[] iArr;
        synchronized (this) {
            iArr = this.mPowerSaveWhitelistExceptIdleAppIdArray;
        }
        return iArr;
    }

    public int[] getAppIdWhitelistInternal() {
        int[] iArr;
        synchronized (this) {
            iArr = this.mPowerSaveWhitelistAllAppIdArray;
        }
        return iArr;
    }

    public int[] getAppIdUserWhitelistInternal() {
        int[] iArr;
        synchronized (this) {
            iArr = this.mPowerSaveWhitelistUserAppIdArray;
        }
        return iArr;
    }

    public int[] getAppIdTempWhitelistInternal() {
        int[] iArr;
        synchronized (this) {
            iArr = this.mTempWhitelistAppIdArray;
        }
        return iArr;
    }

    void addPowerSaveTempWhitelistAppChecked(String packageName, long duration, int userId, String reason) throws RemoteException {
        getContext().enforceCallingPermission("android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST", "No permission to change device idle whitelist");
        int callingUid = Binder.getCallingUid();
        userId = ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(), callingUid, userId, false, false, "addPowerSaveTempWhitelistApp", null);
        long token = Binder.clearCallingIdentity();
        try {
            addPowerSaveTempWhitelistAppInternal(callingUid, packageName, duration, userId, true, reason);
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    void addPowerSaveTempWhitelistAppInternal(int callingUid, String packageName, long duration, int userId, boolean sync, String reason) {
        try {
            addPowerSaveTempWhitelistAppDirectInternal(callingUid, UserHandle.getAppId(getContext().getPackageManager().getPackageUidAsUser(packageName, userId)), duration, sync, reason);
        } catch (NameNotFoundException e) {
        }
    }

    void addPowerSaveTempWhitelistAppDirectInternal(int callingUid, int appId, long duration, boolean sync, String reason) {
        long timeNow = SystemClock.elapsedRealtime();
        Runnable runnable = null;
        synchronized (this) {
            int callingAppId = UserHandle.getAppId(callingUid);
            if (callingAppId < 10000 || this.mPowerSaveWhitelistSystemAppIds.get(callingAppId)) {
                duration = Math.min(duration, this.mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
                Pair<MutableLong, String> entry = (Pair) this.mTempWhitelistAppIdEndTimes.get(appId);
                boolean newEntry = entry == null;
                if (newEntry) {
                    entry = new Pair(new MutableLong(0), reason);
                    this.mTempWhitelistAppIdEndTimes.put(appId, entry);
                }
                ((MutableLong) entry.first).value = timeNow + duration;
                if (DEBUG) {
                    Slog.d(TAG, "Adding AppId " + appId + " to temp whitelist. New entry: " + newEntry);
                }
                if (newEntry) {
                    try {
                        this.mBatteryStats.noteEvent(32785, reason, appId);
                    } catch (RemoteException e) {
                    }
                    postTempActiveTimeoutMessage(appId, duration);
                    updateTempWhitelistAppIdsLocked();
                    if (this.mNetworkPolicyTempWhitelistCallback != null) {
                        if (sync) {
                            runnable = this.mNetworkPolicyTempWhitelistCallback;
                        } else {
                            this.mHandler.post(this.mNetworkPolicyTempWhitelistCallback);
                        }
                    }
                    reportTempWhitelistChangedLocked();
                }
            } else {
                throw new SecurityException("Calling app " + UserHandle.formatUid(callingUid) + " is not on whitelist");
            }
        }
        if (runnable != null) {
            runnable.run();
        }
    }

    public void setNetworkPolicyTempWhitelistCallbackInternal(Runnable callback) {
        synchronized (this) {
            this.mNetworkPolicyTempWhitelistCallback = callback;
        }
    }

    private void postTempActiveTimeoutMessage(int uid, long delay) {
        if (DEBUG) {
            Slog.d(TAG, "postTempActiveTimeoutMessage: uid=" + uid + ", delay=" + delay);
        }
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(6, uid, 0), delay);
    }

    void checkTempAppWhitelistTimeout(int uid) {
        long timeNow = SystemClock.elapsedRealtime();
        if (DEBUG) {
            Slog.d(TAG, "checkTempAppWhitelistTimeout: uid=" + uid + ", timeNow=" + timeNow);
        }
        synchronized (this) {
            Pair<MutableLong, String> entry = (Pair) this.mTempWhitelistAppIdEndTimes.get(uid);
            if (entry == null) {
                return;
            } else if (timeNow >= ((MutableLong) entry.first).value) {
                this.mTempWhitelistAppIdEndTimes.delete(uid);
                if (DEBUG) {
                    Slog.d(TAG, "Removing UID " + uid + " from temp whitelist");
                }
                updateTempWhitelistAppIdsLocked();
                if (this.mNetworkPolicyTempWhitelistCallback != null) {
                    this.mHandler.post(this.mNetworkPolicyTempWhitelistCallback);
                }
                reportTempWhitelistChangedLocked();
                try {
                    this.mBatteryStats.noteEvent(16401, (String) entry.second, uid);
                } catch (RemoteException e) {
                }
            } else {
                if (DEBUG) {
                    Slog.d(TAG, "Time to remove UID " + uid + ": " + ((MutableLong) entry.first).value);
                }
                postTempActiveTimeoutMessage(uid, ((MutableLong) entry.first).value - timeNow);
            }
        }
    }

    public void exitIdleInternal(String reason) {
        synchronized (this) {
            becomeActiveLocked(reason, Binder.getCallingUid());
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void updateConnectivityState(Intent connIntent) {
        synchronized (this) {
            ConnectivityService cm = this.mConnectivityService;
        }
        if (cm != null) {
            NetworkInfo ni = cm.getActiveNetworkInfo();
            synchronized (this) {
                boolean z;
                if (ni == null) {
                    z = false;
                } else if (connIntent == null) {
                    z = ni.isConnected();
                } else {
                    if (ni.getType() != connIntent.getIntExtra("networkType", -1)) {
                        return;
                    }
                    z = !connIntent.getBooleanExtra("noConnectivity", false);
                }
                if (z != this.mNetworkConnected) {
                    this.mNetworkConnected = z;
                    if (z && this.mLightState == 5) {
                        stepLightIdleStateLocked("network");
                    }
                }
            }
        }
    }

    void updateDisplayLocked() {
        this.mCurDisplay = this.mDisplayManager.getDisplay(0);
        boolean screenOn = this.mCurDisplay.getState() == 2;
        if (DEBUG) {
            Slog.d(TAG, "updateDisplayLocked: screenOn=" + screenOn);
        }
        if (!screenOn && this.mScreenOn) {
            this.mScreenOn = false;
            if (!this.mForceIdle) {
                becomeInactiveIfAppropriateLocked();
            }
        } else if (screenOn) {
            this.mScreenOn = true;
            if (!this.mForceIdle) {
                becomeActiveLocked("screen", Process.myUid());
            }
        }
    }

    void updateChargingLocked(boolean charging) {
        if (DEBUG) {
            Slog.i(TAG, "updateChargingLocked: charging=" + charging);
        }
        if (!charging && this.mCharging) {
            this.mCharging = false;
            if (!this.mForceIdle) {
                becomeInactiveIfAppropriateLocked();
            }
        } else if (charging) {
            this.mCharging = charging;
            if (!this.mForceIdle) {
                becomeActiveLocked("charging", Process.myUid());
            }
        }
    }

    void scheduleReportActiveLocked(String activeReason, int activeUid) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(5, activeUid, 0, activeReason));
    }

    void becomeActiveLocked(String activeReason, int activeUid) {
        if (DEBUG) {
            Slog.i(TAG, "becomeActiveLocked, reason = " + activeReason);
        }
        if (this.mState != 0 || this.mLightState != 0) {
            EventLogTags.writeDeviceIdle(0, activeReason);
            EventLogTags.writeDeviceIdleLight(0, activeReason);
            scheduleReportActiveLocked(activeReason, activeUid);
            this.mState = 0;
            this.mLightState = 0;
            this.mInactiveTimeout = this.mConstants.INACTIVE_TIMEOUT;
            this.mCurIdleBudget = 0;
            this.mMaintenanceStartTime = 0;
            resetIdleManagementLocked();
            resetLightIdleManagementLocked();
            addEvent(1);
        }
    }

    void becomeInactiveIfAppropriateLocked() {
        if (DEBUG) {
            Slog.d(TAG, "becomeInactiveIfAppropriateLocked()");
        }
        if ((!this.mScreenOn && !this.mCharging) || this.mForceIdle) {
            if (this.mState == 0 && this.mDeepEnabled) {
                this.mState = 1;
                if (DEBUG) {
                    Slog.d(TAG, "Moved from STATE_ACTIVE to STATE_INACTIVE");
                }
                resetIdleManagementLocked();
                scheduleAlarmLocked(this.mInactiveTimeout, false);
                EventLogTags.writeDeviceIdle(this.mState, "no activity");
            }
            if (this.mLightState == 0 && this.mLightEnabled) {
                this.mLightState = 1;
                if (DEBUG) {
                    Slog.d(TAG, "Moved from LIGHT_STATE_ACTIVE to LIGHT_STATE_INACTIVE");
                }
                resetLightIdleManagementLocked();
                scheduleLightAlarmLocked(this.mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT);
                EventLogTags.writeDeviceIdleLight(this.mLightState, "no activity");
            }
        }
    }

    void resetIdleManagementLocked() {
        this.mNextIdlePendingDelay = 0;
        this.mNextIdleDelay = 0;
        this.mNextLightIdleDelay = 0;
        cancelAlarmLocked();
        cancelSensingTimeoutAlarmLocked();
        cancelLocatingLocked();
        stopMonitoringMotionLocked();
        this.mAnyMotionDetector.stop();
    }

    void resetLightIdleManagementLocked() {
        cancelLightAlarmLocked();
    }

    void exitForceIdleLocked() {
        if (this.mForceIdle) {
            this.mForceIdle = false;
            if (this.mScreenOn || this.mCharging) {
                becomeActiveLocked("exit-force", Process.myUid());
            }
        }
    }

    void stepLightIdleStateLocked(String reason) {
        if (this.mLightState != 7) {
            if (DEBUG) {
                Slog.d(TAG, "stepLightIdleStateLocked: mLightState=" + this.mLightState);
            }
            EventLogTags.writeDeviceIdleLightStep();
            switch (this.mLightState) {
                case 1:
                    this.mCurIdleBudget = this.mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
                    this.mNextLightIdleDelay = this.mConstants.LIGHT_IDLE_TIMEOUT;
                    this.mMaintenanceStartTime = 0;
                    if (!isOpsInactiveLocked()) {
                        this.mLightState = 3;
                        EventLogTags.writeDeviceIdleLight(this.mLightState, reason);
                        scheduleLightAlarmLocked(this.mConstants.LIGHT_PRE_IDLE_TIMEOUT);
                        break;
                    }
                case 3:
                case 6:
                    if (this.mMaintenanceStartTime != 0) {
                        long duration = SystemClock.elapsedRealtime() - this.mMaintenanceStartTime;
                        if (duration < this.mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
                            this.mCurIdleBudget += this.mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration;
                        } else {
                            this.mCurIdleBudget -= duration - this.mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
                        }
                    }
                    this.mMaintenanceStartTime = 0;
                    scheduleLightAlarmLocked(this.mNextLightIdleDelay);
                    this.mNextLightIdleDelay = Math.min(this.mConstants.LIGHT_MAX_IDLE_TIMEOUT, (long) (((float) this.mNextLightIdleDelay) * this.mConstants.LIGHT_IDLE_FACTOR));
                    if (this.mNextLightIdleDelay < this.mConstants.LIGHT_IDLE_TIMEOUT) {
                        this.mNextLightIdleDelay = this.mConstants.LIGHT_IDLE_TIMEOUT;
                    }
                    if (DEBUG) {
                        Slog.d(TAG, "Moved to LIGHT_STATE_IDLE.");
                    }
                    this.mLightState = 4;
                    EventLogTags.writeDeviceIdleLight(this.mLightState, reason);
                    addEvent(2);
                    this.mHandler.sendEmptyMessage(3);
                    break;
                case 4:
                case 5:
                    if (!this.mNetworkConnected && this.mLightState != 5) {
                        scheduleLightAlarmLocked(this.mNextLightIdleDelay);
                        if (DEBUG) {
                            Slog.d(TAG, "Moved to LIGHT_WAITING_FOR_NETWORK.");
                        }
                        this.mLightState = 5;
                        EventLogTags.writeDeviceIdleLight(this.mLightState, reason);
                        break;
                    }
                    this.mActiveIdleOpCount = 1;
                    this.mActiveIdleWakeLock.acquire();
                    this.mMaintenanceStartTime = SystemClock.elapsedRealtime();
                    if (this.mCurIdleBudget < this.mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
                        this.mCurIdleBudget = this.mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
                    } else if (this.mCurIdleBudget > this.mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
                        this.mCurIdleBudget = this.mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
                    }
                    scheduleLightAlarmLocked(this.mCurIdleBudget);
                    if (DEBUG) {
                        Slog.d(TAG, "Moved from LIGHT_STATE_IDLE to LIGHT_STATE_IDLE_MAINTENANCE.");
                    }
                    this.mLightState = 6;
                    EventLogTags.writeDeviceIdleLight(this.mLightState, reason);
                    addEvent(3);
                    this.mHandler.sendEmptyMessage(4);
                    break;
                    break;
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void stepIdleStateLocked(String reason) {
        if (DEBUG) {
            Slog.d(TAG, "stepIdleStateLocked: mState=" + this.mState);
        }
        EventLogTags.writeDeviceIdleStep();
        if (this.mConstants.MIN_TIME_TO_ALARM + SystemClock.elapsedRealtime() <= this.mAlarmManager.getNextWakeFromIdleTime()) {
            switch (this.mState) {
                case 1:
                    startMonitoringMotionLocked();
                    scheduleAlarmLocked(this.mConstants.IDLE_AFTER_INACTIVE_TIMEOUT, false);
                    this.mNextIdlePendingDelay = this.mConstants.IDLE_PENDING_TIMEOUT;
                    this.mNextIdleDelay = this.mConstants.IDLE_TIMEOUT;
                    this.mState = 2;
                    if (DEBUG) {
                        Slog.d(TAG, "Moved from STATE_INACTIVE to STATE_IDLE_PENDING.");
                    }
                    EventLogTags.writeDeviceIdle(this.mState, reason);
                    break;
                case 2:
                    this.mState = 3;
                    if (DEBUG) {
                        Slog.d(TAG, "Moved from STATE_IDLE_PENDING to STATE_SENSING.");
                    }
                    EventLogTags.writeDeviceIdle(this.mState, reason);
                    scheduleSensingTimeoutAlarmLocked(this.mConstants.SENSING_TIMEOUT);
                    cancelLocatingLocked();
                    this.mNotMoving = false;
                    this.mLocated = false;
                    this.mLastGenericLocation = null;
                    this.mLastGpsLocation = null;
                    if (!this.mForceIdle) {
                        this.mAnyMotionDetector.checkForAnyMotion();
                        break;
                    }
                    break;
                case 3:
                    cancelSensingTimeoutAlarmLocked();
                    this.mState = 4;
                    if (DEBUG) {
                        Slog.d(TAG, "Moved from STATE_SENSING to STATE_LOCATING.");
                    }
                    EventLogTags.writeDeviceIdle(this.mState, reason);
                    scheduleAlarmLocked(this.mConstants.LOCATING_TIMEOUT, false);
                    if (this.mForceIdle) {
                        if (DEBUG) {
                            Slog.d(TAG, "forceidle, not check locating");
                            break;
                        }
                    }
                    if (this.mLocationManager == null || this.mLocationManager.getProvider("network") == null) {
                        this.mHasNetworkLocation = false;
                    } else {
                        this.mLocationManager.requestLocationUpdates(this.mLocationRequest, this.mGenericLocationListener, this.mHandler.getLooper());
                        this.mLocating = true;
                    }
                    if (this.mLocationManager == null || this.mLocationManager.getProvider("gps") == null) {
                        this.mHasGps = false;
                    } else {
                        this.mHasGps = true;
                        this.mLocationManager.requestLocationUpdates("gps", 1000, 5.0f, this.mGpsLocationListener, this.mHandler.getLooper());
                        this.mLocating = true;
                    }
                    break;
                    break;
                case 4:
                    break;
                case 5:
                    this.mActiveIdleOpCount = 1;
                    this.mActiveIdleWakeLock.acquire();
                    scheduleAlarmLocked(this.mNextIdlePendingDelay, false);
                    if (DEBUG) {
                        Slog.d(TAG, "Moved from STATE_IDLE to STATE_IDLE_MAINTENANCE. Next alarm in " + this.mNextIdlePendingDelay + " ms.");
                    }
                    this.mMaintenanceStartTime = SystemClock.elapsedRealtime();
                    this.mNextIdlePendingDelay = Math.min(this.mConstants.MAX_IDLE_PENDING_TIMEOUT, (long) (((float) this.mNextIdlePendingDelay) * this.mConstants.IDLE_PENDING_FACTOR));
                    if (this.mNextIdlePendingDelay < this.mConstants.IDLE_PENDING_TIMEOUT) {
                        this.mNextIdlePendingDelay = this.mConstants.IDLE_PENDING_TIMEOUT;
                    }
                    this.mState = 6;
                    EventLogTags.writeDeviceIdle(this.mState, reason);
                    addEvent(5);
                    this.mHandler.sendEmptyMessage(4);
                    break;
                case 6:
                    break;
            }
        }
        if (this.mState != 0) {
            becomeActiveLocked("alarm", Process.myUid());
            becomeInactiveIfAppropriateLocked();
        }
    }

    void incActiveIdleOps() {
        synchronized (this) {
            this.mActiveIdleOpCount++;
        }
    }

    void decActiveIdleOps() {
        synchronized (this) {
            this.mActiveIdleOpCount--;
            if (this.mActiveIdleOpCount <= 0) {
                exitMaintenanceEarlyIfNeededLocked();
                this.mActiveIdleWakeLock.release();
            }
        }
    }

    void setJobsActive(boolean active) {
        synchronized (this) {
            this.mJobsActive = active;
            reportMaintenanceActivityIfNeededLocked();
            if (!active) {
                exitMaintenanceEarlyIfNeededLocked();
            }
        }
    }

    void setAlarmsActive(boolean active) {
        synchronized (this) {
            this.mAlarmsActive = active;
            if (!active) {
                exitMaintenanceEarlyIfNeededLocked();
            }
        }
    }

    boolean registerMaintenanceActivityListener(IMaintenanceActivityListener listener) {
        boolean z;
        synchronized (this) {
            this.mMaintenanceActivityListeners.register(listener);
            z = this.mReportedMaintenanceActivity;
        }
        return z;
    }

    void unregisterMaintenanceActivityListener(IMaintenanceActivityListener listener) {
        synchronized (this) {
            this.mMaintenanceActivityListeners.unregister(listener);
        }
    }

    void reportMaintenanceActivityIfNeededLocked() {
        boolean active = this.mJobsActive;
        if (active != this.mReportedMaintenanceActivity) {
            int i;
            this.mReportedMaintenanceActivity = active;
            MyHandler myHandler = this.mHandler;
            if (this.mReportedMaintenanceActivity) {
                i = 1;
            } else {
                i = 0;
            }
            this.mHandler.sendMessage(myHandler.obtainMessage(7, i, 0));
        }
    }

    boolean isOpsInactiveLocked() {
        return (this.mActiveIdleOpCount > 0 || this.mJobsActive || this.mAlarmsActive) ? false : true;
    }

    void exitMaintenanceEarlyIfNeededLocked() {
        if (!(this.mState == 6 || this.mLightState == 6)) {
            if (this.mLightState != 3) {
                return;
            }
        }
        if (isOpsInactiveLocked()) {
            long now = SystemClock.elapsedRealtime();
            if (DEBUG) {
                StringBuilder sb = new StringBuilder();
                sb.append("Exit: start=");
                TimeUtils.formatDuration(this.mMaintenanceStartTime, sb);
                sb.append(" now=");
                TimeUtils.formatDuration(now, sb);
                Slog.d(TAG, sb.toString());
            }
            if (this.mState == 6) {
                stepIdleStateLocked("s:early");
            } else if (this.mLightState == 3) {
                stepLightIdleStateLocked("s:predone");
            } else {
                stepLightIdleStateLocked("s:early");
            }
        }
    }

    void motionLocked() {
        if (DEBUG) {
            Slog.d(TAG, "motionLocked()");
        }
        handleMotionDetectedLocked(this.mConstants.MOTION_INACTIVE_TIMEOUT, "motion");
    }

    void handleMotionDetectedLocked(long timeout, String type) {
        boolean becomeInactive = false;
        if (this.mState != 0) {
            scheduleReportActiveLocked(type, Process.myUid());
            this.mState = 0;
            this.mInactiveTimeout = timeout;
            this.mCurIdleBudget = 0;
            this.mMaintenanceStartTime = 0;
            EventLogTags.writeDeviceIdle(this.mState, type);
            addEvent(1);
            becomeInactive = true;
        }
        if (this.mLightState == 7) {
            this.mLightState = 0;
            EventLogTags.writeDeviceIdleLight(this.mLightState, type);
            becomeInactive = true;
        }
        if (becomeInactive) {
            becomeInactiveIfAppropriateLocked();
        }
    }

    void receivedGenericLocationLocked(Location location) {
        if (this.mState != 4) {
            cancelLocatingLocked();
            return;
        }
        if (DEBUG) {
            Slog.d(TAG, "Generic location: ");
        }
        this.mLastGenericLocation = new Location(location);
        if (location.getAccuracy() <= this.mConstants.LOCATION_ACCURACY || !this.mHasGps) {
            this.mLocated = true;
            if (this.mNotMoving) {
                stepIdleStateLocked("s:location");
            }
        }
    }

    void receivedGpsLocationLocked(Location location) {
        if (this.mState != 4) {
            cancelLocatingLocked();
            return;
        }
        if (DEBUG) {
            Slog.d(TAG, "GPS location: ");
        }
        this.mLastGpsLocation = new Location(location);
        if (location.getAccuracy() <= this.mConstants.LOCATION_ACCURACY) {
            this.mLocated = true;
            if (this.mNotMoving) {
                stepIdleStateLocked("s:gps");
            }
        }
    }

    void startMonitoringMotionLocked() {
        if (DEBUG) {
            Slog.d(TAG, "startMonitoringMotionLocked()");
        }
        if (this.mMotionSensor != null && !this.mMotionListener.active) {
            this.mMotionListener.registerLocked();
        }
    }

    void stopMonitoringMotionLocked() {
        if (DEBUG) {
            Slog.d(TAG, "stopMonitoringMotionLocked()");
        }
        if (this.mMotionSensor != null && this.mMotionListener.active) {
            this.mMotionListener.unregisterLocked();
        }
    }

    void cancelAlarmLocked() {
        if (this.mNextAlarmTime != 0) {
            this.mNextAlarmTime = 0;
            this.mAlarmManager.cancel(this.mDeepAlarmListener);
        }
    }

    void cancelLightAlarmLocked() {
        if (this.mNextLightAlarmTime != 0) {
            this.mNextLightAlarmTime = 0;
            this.mAlarmManager.cancel(this.mLightAlarmListener);
        }
    }

    void cancelLocatingLocked() {
        if (this.mLocating) {
            this.mLocationManager.removeUpdates(this.mGenericLocationListener);
            this.mLocationManager.removeUpdates(this.mGpsLocationListener);
            this.mLocating = false;
        }
    }

    void cancelSensingTimeoutAlarmLocked() {
        if (this.mNextSensingTimeoutAlarmTime != 0) {
            this.mNextSensingTimeoutAlarmTime = 0;
            this.mAlarmManager.cancel(this.mSensingTimeoutAlarmListener);
        }
    }

    void scheduleAlarmLocked(long delay, boolean idleUntil) {
        if (DEBUG) {
            Slog.d(TAG, "scheduleAlarmLocked(" + delay + ", " + idleUntil + ")");
        }
        if (this.mMotionSensor != null) {
            this.mNextAlarmTime = SystemClock.elapsedRealtime() + delay;
            if (idleUntil) {
                this.mAlarmManager.setIdleUntil(2, this.mNextAlarmTime, "DeviceIdleController.deep", this.mDeepAlarmListener, this.mHandler);
            } else {
                this.mAlarmManager.set(2, this.mNextAlarmTime, "DeviceIdleController.deep", this.mDeepAlarmListener, this.mHandler);
            }
        }
    }

    void scheduleLightAlarmLocked(long delay) {
        if (DEBUG) {
            Slog.d(TAG, "scheduleLightAlarmLocked(" + delay + ")");
        }
        this.mNextLightAlarmTime = SystemClock.elapsedRealtime() + delay;
        this.mAlarmManager.set(2, this.mNextLightAlarmTime, "DeviceIdleController.light", this.mLightAlarmListener, this.mHandler);
    }

    void scheduleSensingTimeoutAlarmLocked(long delay) {
        if (DEBUG) {
            Slog.d(TAG, "scheduleSensingAlarmLocked(" + delay + ")");
        }
        this.mNextSensingTimeoutAlarmTime = SystemClock.elapsedRealtime() + delay;
        this.mAlarmManager.set(2, this.mNextSensingTimeoutAlarmTime, "DeviceIdleController.sensing", this.mSensingTimeoutAlarmListener, this.mHandler);
    }

    private static int[] buildAppIdArray(ArrayMap<String, Integer> systemApps, ArrayMap<String, Integer> userApps, SparseBooleanArray outAppIds) {
        int i;
        outAppIds.clear();
        if (systemApps != null) {
            for (i = 0; i < systemApps.size(); i++) {
                outAppIds.put(((Integer) systemApps.valueAt(i)).intValue(), true);
            }
        }
        if (userApps != null) {
            for (i = 0; i < userApps.size(); i++) {
                outAppIds.put(((Integer) userApps.valueAt(i)).intValue(), true);
            }
        }
        int size = outAppIds.size();
        int[] appids = new int[size];
        for (i = 0; i < size; i++) {
            appids[i] = outAppIds.keyAt(i);
        }
        return appids;
    }

    private void updateWhitelistAppIdsLocked() {
        this.mPowerSaveWhitelistExceptIdleAppIdArray = buildAppIdArray(this.mPowerSaveWhitelistAppsExceptIdle, this.mPowerSaveWhitelistUserApps, this.mPowerSaveWhitelistExceptIdleAppIds);
        this.mPowerSaveWhitelistAllAppIdArray = buildAppIdArray(this.mPowerSaveWhitelistApps, this.mPowerSaveWhitelistUserApps, this.mPowerSaveWhitelistAllAppIds);
        this.mPowerSaveWhitelistUserAppIdArray = buildAppIdArray(null, this.mPowerSaveWhitelistUserApps, this.mPowerSaveWhitelistUserAppIds);
        if (this.mLocalPowerManager != null) {
            if (DEBUG) {
                Slog.d(TAG, "Setting wakelock whitelist to " + Arrays.toString(this.mPowerSaveWhitelistAllAppIdArray));
            }
            this.mLocalPowerManager.setDeviceIdleWhitelist(this.mPowerSaveWhitelistAllAppIdArray);
        }
        if (this.mLocalAlarmManager != null) {
            if (DEBUG) {
                Slog.d(TAG, "Setting alarm whitelist to " + Arrays.toString(this.mPowerSaveWhitelistUserAppIdArray));
            }
            this.mLocalAlarmManager.setDeviceIdleUserWhitelist(this.mPowerSaveWhitelistUserAppIdArray);
        }
    }

    private void updateTempWhitelistAppIdsLocked() {
        int size = this.mTempWhitelistAppIdEndTimes.size();
        if (this.mTempWhitelistAppIdArray.length != size) {
            this.mTempWhitelistAppIdArray = new int[size];
        }
        for (int i = 0; i < size; i++) {
            this.mTempWhitelistAppIdArray[i] = this.mTempWhitelistAppIdEndTimes.keyAt(i);
        }
        if (this.mLocalPowerManager != null) {
            if (DEBUG) {
                Slog.d(TAG, "Setting wakelock temp whitelist to " + Arrays.toString(this.mTempWhitelistAppIdArray));
            }
            this.mLocalPowerManager.setDeviceIdleTempWhitelist(this.mTempWhitelistAppIdArray);
        }
    }

    private void reportPowerSaveWhitelistChangedLocked() {
        Intent intent = new Intent("android.os.action.POWER_SAVE_WHITELIST_CHANGED");
        intent.addFlags(1073741824);
        getContext().sendBroadcastAsUser(intent, UserHandle.SYSTEM);
    }

    private void reportTempWhitelistChangedLocked() {
        Intent intent = new Intent("android.os.action.POWER_SAVE_TEMP_WHITELIST_CHANGED");
        intent.addFlags(1073741824);
        getContext().sendBroadcastAsUser(intent, UserHandle.SYSTEM);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void readConfigFileLocked() {
        if (DEBUG) {
            Slog.d(TAG, "Reading config from " + this.mConfigFile.getBaseFile());
        }
        this.mPowerSaveWhitelistUserApps.clear();
        try {
            FileInputStream stream = this.mConfigFile.openRead();
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(stream, StandardCharsets.UTF_8.name());
                readConfigFileLocked(parser);
                try {
                    stream.close();
                } catch (IOException e) {
                }
            } catch (XmlPullParserException e2) {
            } catch (Throwable th) {
                try {
                    stream.close();
                } catch (IOException e3) {
                }
            }
        } catch (FileNotFoundException e4) {
        }
    }

    private boolean updateWhitelistFromDB(boolean ignoreDbNotExist) {
        PackageManager pm = getContext().getPackageManager();
        Bundle bundle = null;
        ArrayList arrayList = null;
        try {
            Slog.d(TAG, "begin to read unprotectlist from DB");
            bundle = getContext().getContentResolver().call(Uri.parse("content://com.huawei.android.smartpowerprovider"), "hsm_get_freeze_list", "unprotect", null);
        } catch (Exception e) {
            Slog.d(TAG, "read unprotectlist fail:" + e);
            if (!ignoreDbNotExist) {
                return false;
            }
        }
        if (bundle != null) {
            arrayList = bundle.getStringArrayList("frz_unprotect");
            Slog.d(TAG, "unprotect list: " + arrayList);
        } else {
            Slog.d(TAG, "read unprotectlist wrong , Bundle is null");
        }
        List<PackageInfo> packages = pm.getInstalledPackages(DumpState.DUMP_PREFERRED_XML);
        synchronized (this) {
            for (int i = 0; i < packages.size(); i++) {
                String pkgName = ((PackageInfo) packages.get(i)).packageName;
                if (!this.mPowerSaveWhitelistUserApps.containsKey(pkgName)) {
                    try {
                        ApplicationInfo ai = pm.getApplicationInfo(pkgName, DumpState.DUMP_PREFERRED_XML);
                        if (arrayList == null || !arrayList.contains(pkgName)) {
                            this.mPowerSaveWhitelistUserApps.put(ai.packageName, Integer.valueOf(UserHandle.getAppId(ai.uid)));
                        }
                    } catch (NameNotFoundException e2) {
                        Slog.d(TAG, "NameNotFound: " + pkgName);
                    }
                }
            }
            updateWhitelistAppIdsLocked();
            reportPowerSaveWhitelistChangedLocked();
        }
        return true;
    }

    private void readConfigFileLocked(XmlPullParser parser) {
        int type;
        PackageManager pm = getContext().getPackageManager();
        do {
            try {
                type = parser.next();
                if (type == 2) {
                    break;
                }
            } catch (IllegalStateException e) {
                Slog.w(TAG, "Failed parsing config " + e);
                return;
            } catch (NullPointerException e2) {
                Slog.w(TAG, "Failed parsing config " + e2);
                return;
            } catch (NumberFormatException e3) {
                Slog.w(TAG, "Failed parsing config " + e3);
                return;
            } catch (XmlPullParserException e4) {
                Slog.w(TAG, "Failed parsing config " + e4);
                return;
            } catch (IOException e5) {
                Slog.w(TAG, "Failed parsing config " + e5);
                return;
            } catch (IndexOutOfBoundsException e6) {
                Slog.w(TAG, "Failed parsing config " + e6);
                return;
            }
        } while (type != 1);
        if (type != 2) {
            throw new IllegalStateException("no start tag found");
        }
        int outerDepth = parser.getDepth();
        while (true) {
            type = parser.next();
            if (type == 1) {
                return;
            }
            if (type == 3 && parser.getDepth() <= outerDepth) {
                return;
            }
            if (!(type == 3 || type == 4)) {
                if (parser.getName().equals("wl")) {
                    String name = parser.getAttributeValue(null, "n");
                    if (name != null) {
                        try {
                            ApplicationInfo ai = pm.getApplicationInfo(name, DumpState.DUMP_PREFERRED_XML);
                            this.mPowerSaveWhitelistUserApps.put(ai.packageName, Integer.valueOf(UserHandle.getAppId(ai.uid)));
                        } catch (NameNotFoundException e7) {
                        }
                    }
                } else {
                    Slog.w(TAG, "Unknown element under <config>: " + parser.getName());
                    XmlUtils.skipCurrentTag(parser);
                }
            }
        }
    }

    void writeConfigFileLocked() {
        this.mHandler.removeMessages(1);
        this.mHandler.sendEmptyMessageDelayed(1, 5000);
    }

    void handleWriteConfigFile() {
        ByteArrayOutputStream memStream = new ByteArrayOutputStream();
        try {
            synchronized (this) {
                XmlSerializer out = new FastXmlSerializer();
                out.setOutput(memStream, StandardCharsets.UTF_8.name());
                writeConfigFileLocked(out);
            }
        } catch (IOException e) {
        }
        synchronized (this.mConfigFile) {
            FileOutputStream fileOutputStream = null;
            try {
                fileOutputStream = this.mConfigFile.startWrite();
                memStream.writeTo(fileOutputStream);
                fileOutputStream.flush();
                FileUtils.sync(fileOutputStream);
                fileOutputStream.close();
                this.mConfigFile.finishWrite(fileOutputStream);
            } catch (IOException e2) {
                Slog.w(TAG, "Error writing config file", e2);
                this.mConfigFile.failWrite(fileOutputStream);
            }
        }
    }

    void writeConfigFileLocked(XmlSerializer out) throws IOException {
        out.startDocument(null, Boolean.valueOf(true));
        out.startTag(null, "config");
        for (int i = 0; i < this.mPowerSaveWhitelistUserApps.size(); i++) {
            String name = (String) this.mPowerSaveWhitelistUserApps.keyAt(i);
            out.startTag(null, "wl");
            out.attribute(null, "n", name);
            out.endTag(null, "wl");
        }
        out.endTag(null, "config");
        out.endDocument();
    }

    static void dumpHelp(PrintWriter pw) {
        pw.println("Device idle controller (deviceidle) commands:");
        pw.println("  help");
        pw.println("    Print this help text.");
        pw.println("  step [light|deep]");
        pw.println("    Immediately step to next state, without waiting for alarm.");
        pw.println("  force-idle [light|deep]");
        pw.println("    Force directly into idle mode, regardless of other device state.");
        pw.println("  force-inactive");
        pw.println("    Force to be inactive, ready to freely step idle states.");
        pw.println("  unforce");
        pw.println("    Resume normal functioning after force-idle or force-inactive.");
        pw.println("  get [light|deep|force|screen|charging|network]");
        pw.println("    Retrieve the current given state.");
        pw.println("  disable [light|deep|all]");
        pw.println("    Completely disable device idle mode.");
        pw.println("  enable [light|deep|all]");
        pw.println("    Re-enable device idle mode after it had previously been disabled.");
        pw.println("  enabled [light|deep|all]");
        pw.println("    Print 1 if device idle mode is currently enabled, else 0.");
        pw.println("  whitelist");
        pw.println("    Print currently whitelisted apps.");
        pw.println("  whitelist [package ...]");
        pw.println("    Add (prefix with +) or remove (prefix with -) packages.");
        pw.println("  tempwhitelist");
        pw.println("    Print packages that are temporarily whitelisted.");
        pw.println("  tempwhitelist [-u] [package ..]");
        pw.println("    Temporarily place packages in whitelist for 10 seconds.");
    }

    void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        if (getContext().checkCallingOrSelfPermission("android.permission.DUMP") != 0) {
            pw.println("Permission Denial: can't dump DeviceIdleController from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + "android.permission.DUMP");
            return;
        }
        int i;
        if (args != null) {
            int userId = 0;
            i = 0;
            while (i < args.length) {
                String arg = args[i];
                if ("-h".equals(arg)) {
                    dumpHelp(pw);
                    return;
                }
                if ("-u".equals(arg)) {
                    i++;
                    if (i < args.length) {
                        userId = Integer.parseInt(args[i]);
                    }
                } else if (!"-a".equals(arg)) {
                    if (arg.length() <= 0 || arg.charAt(0) != '-') {
                        Shell shell = new Shell();
                        shell.userId = userId;
                        String[] newArgs = new String[(args.length - i)];
                        System.arraycopy(args, i, newArgs, 0, args.length - i);
                        shell.exec(this.mBinderService, null, fd, null, newArgs, new ResultReceiver(null));
                        return;
                    }
                    pw.println("Unknown option: " + arg);
                    return;
                }
                i++;
            }
        }
        synchronized (this) {
            this.mConstants.dump(pw);
            if (this.mEventCmds[0] != 0) {
                pw.println("  Idling history:");
                long now = SystemClock.elapsedRealtime();
                for (i = 99; i >= 0; i--) {
                    if (this.mEventCmds[i] != 0) {
                        String label;
                        switch (this.mEventCmds[i]) {
                            case 1:
                                label = "     normal";
                                break;
                            case 2:
                                label = " light-idle";
                                break;
                            case 3:
                                label = "light-maint";
                                break;
                            case 4:
                                label = "  deep-idle";
                                break;
                            case 5:
                                label = " deep-maint";
                                break;
                            default:
                                label = "         ??";
                                break;
                        }
                        pw.print("    ");
                        pw.print(label);
                        pw.print(": ");
                        TimeUtils.formatDuration(this.mEventTimes[i], now, pw);
                        pw.println();
                    }
                }
            }
            int size = this.mPowerSaveWhitelistAppsExceptIdle.size();
            if (size > 0) {
                pw.println("  Whitelist (except idle) system apps:");
                for (i = 0; i < size; i++) {
                    pw.print("    ");
                    pw.println((String) this.mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
                }
            }
            size = this.mPowerSaveWhitelistApps.size();
            if (size > 0) {
                pw.println("  Whitelist system apps:");
                for (i = 0; i < size; i++) {
                    pw.print("    ");
                    pw.println((String) this.mPowerSaveWhitelistApps.keyAt(i));
                }
            }
            size = this.mPowerSaveWhitelistUserApps.size();
            if (size > 0) {
                pw.println("  Whitelist user apps:");
                for (i = 0; i < size; i++) {
                    pw.print("    ");
                    pw.println((String) this.mPowerSaveWhitelistUserApps.keyAt(i));
                }
            }
            size = this.mPowerSaveWhitelistExceptIdleAppIds.size();
            if (size > 0) {
                pw.println("  Whitelist (except idle) all app ids:");
                for (i = 0; i < size; i++) {
                    pw.print("    ");
                    pw.print(this.mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
                    pw.println();
                }
            }
            size = this.mPowerSaveWhitelistUserAppIds.size();
            if (size > 0) {
                pw.println("  Whitelist user app ids:");
                for (i = 0; i < size; i++) {
                    pw.print("    ");
                    pw.print(this.mPowerSaveWhitelistUserAppIds.keyAt(i));
                    pw.println();
                }
            }
            size = this.mPowerSaveWhitelistAllAppIds.size();
            if (size > 0) {
                pw.println("  Whitelist all app ids:");
                for (i = 0; i < size; i++) {
                    pw.print("    ");
                    pw.print(this.mPowerSaveWhitelistAllAppIds.keyAt(i));
                    pw.println();
                }
            }
            dumpTempWhitelistSchedule(pw, true);
            size = this.mTempWhitelistAppIdArray != null ? this.mTempWhitelistAppIdArray.length : 0;
            if (size > 0) {
                pw.println("  Temp whitelist app ids:");
                for (i = 0; i < size; i++) {
                    pw.print("    ");
                    pw.print(this.mTempWhitelistAppIdArray[i]);
                    pw.println();
                }
            }
            pw.print("  mLightEnabled=");
            pw.print(this.mLightEnabled);
            pw.print("  mDeepEnabled=");
            pw.println(this.mDeepEnabled);
            pw.print("  mForceIdle=");
            pw.println(this.mForceIdle);
            pw.print("  mMotionSensor=");
            pw.println(this.mMotionSensor);
            pw.print("  mCurDisplay=");
            pw.println(this.mCurDisplay);
            pw.print("  mScreenOn=");
            pw.println(this.mScreenOn);
            pw.print("  mNetworkConnected=");
            pw.println(this.mNetworkConnected);
            pw.print("  mCharging=");
            pw.println(this.mCharging);
            pw.print("  mMotionActive=");
            pw.println(this.mMotionListener.active);
            pw.print("  mNotMoving=");
            pw.println(this.mNotMoving);
            pw.print("  mLocating=");
            pw.print(this.mLocating);
            pw.print(" mHasGps=");
            pw.print(this.mHasGps);
            pw.print(" mHasNetwork=");
            pw.print(this.mHasNetworkLocation);
            pw.print(" mLocated=");
            pw.println(this.mLocated);
            if (this.mLastGenericLocation != null) {
                pw.print("  mLastGenericLocation=");
                pw.println(this.mLastGenericLocation);
            }
            if (this.mLastGpsLocation != null) {
                pw.print("  mLastGpsLocation=");
                pw.println(this.mLastGpsLocation);
            }
            pw.print("  mState=");
            pw.print(stateToString(this.mState));
            pw.print(" mLightState=");
            pw.println(lightStateToString(this.mLightState));
            pw.print("  mInactiveTimeout=");
            TimeUtils.formatDuration(this.mInactiveTimeout, pw);
            pw.println();
            if (this.mActiveIdleOpCount != 0) {
                pw.print("  mActiveIdleOpCount=");
                pw.println(this.mActiveIdleOpCount);
            }
            if (this.mNextAlarmTime != 0) {
                pw.print("  mNextAlarmTime=");
                TimeUtils.formatDuration(this.mNextAlarmTime, SystemClock.elapsedRealtime(), pw);
                pw.println();
            }
            if (this.mNextIdlePendingDelay != 0) {
                pw.print("  mNextIdlePendingDelay=");
                TimeUtils.formatDuration(this.mNextIdlePendingDelay, pw);
                pw.println();
            }
            if (this.mNextIdleDelay != 0) {
                pw.print("  mNextIdleDelay=");
                TimeUtils.formatDuration(this.mNextIdleDelay, pw);
                pw.println();
            }
            if (this.mNextLightIdleDelay != 0) {
                pw.print("  mNextIdleDelay=");
                TimeUtils.formatDuration(this.mNextLightIdleDelay, pw);
                pw.println();
            }
            if (this.mNextLightAlarmTime != 0) {
                pw.print("  mNextLightAlarmTime=");
                TimeUtils.formatDuration(this.mNextLightAlarmTime, SystemClock.elapsedRealtime(), pw);
                pw.println();
            }
            if (this.mCurIdleBudget != 0) {
                pw.print("  mCurIdleBudget=");
                TimeUtils.formatDuration(this.mCurIdleBudget, pw);
                pw.println();
            }
            if (this.mMaintenanceStartTime != 0) {
                pw.print("  mMaintenanceStartTime=");
                TimeUtils.formatDuration(this.mMaintenanceStartTime, SystemClock.elapsedRealtime(), pw);
                pw.println();
            }
            if (this.mJobsActive) {
                pw.print("  mJobsActive=");
                pw.println(this.mJobsActive);
            }
            if (this.mAlarmsActive) {
                pw.print("  mAlarmsActive=");
                pw.println(this.mAlarmsActive);
            }
        }
    }

    void dumpTempWhitelistSchedule(PrintWriter pw, boolean printTitle) {
        int size = this.mTempWhitelistAppIdEndTimes.size();
        if (size > 0) {
            String prefix = "";
            if (printTitle) {
                pw.println("  Temp whitelist schedule:");
                prefix = "    ";
            }
            long timeNow = SystemClock.elapsedRealtime();
            for (int i = 0; i < size; i++) {
                pw.print(prefix);
                pw.print("UID=");
                pw.print(this.mTempWhitelistAppIdEndTimes.keyAt(i));
                pw.print(": ");
                Pair<MutableLong, String> entry = (Pair) this.mTempWhitelistAppIdEndTimes.valueAt(i);
                TimeUtils.formatDuration(((MutableLong) entry.first).value, timeNow, pw);
                pw.print(" - ");
                pw.println((String) entry.second);
            }
        }
    }

    public int forceIdleInternal() {
        synchronized (this) {
            if (!this.mDeepEnabled) {
                Slog.d(TAG, "Unable to go idle; not enabled");
                return -1;
            } else if (this.mForceIdle) {
                Slog.d(TAG, "now it is in ForceIdle by dump");
                return 0;
            } else {
                this.mForceIdle = true;
                becomeInactiveIfAppropriateLocked();
                int curState = this.mState;
                while (curState != 5) {
                    stepIdleStateLocked("s:shell");
                    if (curState == this.mState) {
                        Slog.d(TAG, "Unable to go idle; stopped at " + stateToString(this.mState));
                        exitForceIdleLocked();
                        return -1;
                    }
                    curState = this.mState;
                }
                this.mForceIdle = false;
                Slog.d(TAG, "Now forced in to idle mode");
                return 0;
            }
        }
    }
}
